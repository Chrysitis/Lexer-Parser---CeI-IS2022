// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import java.io.FileReader;
import java.io.BufferedReader;
/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s){ this.s=s; }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;
    
    @Override
    public void syntax_error(Symbol current_token) {
      syntaxErrs += 1;
      System.out.println(
        "SYNTAX ERROR AT LINE " + (current_token.left+1) + " COLUMN " + current_token.right +
          " VALUE: " + current_token.value + " - ");
    }

    public void initParser(String file){
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    new Lexer(br));
            Object result = codeParser.parse().value;
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            //ex.printStackTrace();
        }
    }

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE;
terminal    RETURN, MAIN, FUNC;
terminal    READ, PRINT;

// Boolean.
terminal    TRUE, FALSE;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Literals.
terminal    INTLIT, FLOATLIT;
terminal    CHARLIT, STRINGLIT;
// Identifiers.
terminal ID;


/* Non terminals */
non terminal  ini;       
//non terminal Integer  expr;      
non terminal  main, function;    
non terminal  codeBlock;
non terminal  varCreation, varCreationAsign;
non terminal  printFunction, readFunction;
non terminal  parameters, parametersInv;
//non terminal  expr, factor, termino;
// Precedence and associativity declarations

// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          main | function
          |
          main ini
          |
          function ini
          ;

// ---------- main function (no params) ----------
main ::= 
          INT MAIN LPAREN RPAREN LCURLY RCURLY
          |
          INT MAIN LPAREN RPAREN LCURLY codeBlock RCURLY
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.*/
function ::=
          INT ID LPAREN RPAREN LCURLY RCURLY
          |
          CHAR ID LPAREN RPAREN LCURLY RCURLY
          |
          BOOL ID LPAREN RPAREN LCURLY RCURLY
          |
          INT ID LPAREN parameters RPAREN LCURLY RCURLY
          |
          CHAR ID LPAREN parameters RPAREN LCURLY RCURLY
          |
          BOOL ID LPAREN parameters RPAREN LCURLY RCURLY
          |
          INT ID LPAREN parametersInv RPAREN LCURLY RCURLY
          |
          CHAR ID LPAREN parametersInv RPAREN LCURLY RCURLY
          |
          BOOL ID LPAREN parametersInv RPAREN LCURLY RCURLY
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID COMMA parameters
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT | STRINGLIT | BOOL | ID
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          ID COMMA parametersInv
          ;

// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          varCreation | varCreationAsign | printFunction | readFunction
          |
          varCreation codeBlock 
          |
          varCreationAsign codeBlock
          |
          printFunction codeBlock
          |
          readFunction codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreation ::=   
          INT ID HASH
          |
          CHAR ID HASH
          |
          BOOL ID HASH
          |
          ARRAY ID HASH
          |
          STRING ID HASH
          ;
varCreationAsign ::=
          INT ID EQ INTLIT HASH
          |
          BOOL ID EQ TRUE HASH
          |
          BOOL ID EQ FALSE HASH
          | 
          CHAR ID EQ CHARLIT HASH 
          | 
          FLOAT ID EQ FLOATLIT HASH
          |
          STRING ID EQ STRINGLIT HASH
          //|
          //ARRAY ID EQ ARRAYLIT HASH
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT LPAREN INTLIT RPAREN HASH
          |
          PRINT LPAREN FLOATLIT RPAREN HASH
          |
          PRINT LPAREN CHARLIT RPAREN HASH
          |
          PRINT LPAREN STRINGLIT RPAREN HASH
          |
          PRINT LPAREN ID RPAREN HASH
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          READ HASH
          ;
/*
    expr_list ::= expr_list expr_part
                  |
                  expr_part
                  ;

   expr_part ::= expr:e
                  {:
                    System.out.println(" = " + e); 
                  :} 
                  HASH
                 ;
                  
        

   expr      ::=  expr:e ADD factor:f
                  {:
                    RESULT = new Integer(e.intValue() + f.intValue());
                  :}
                  |
                  expr:e SUBS factor:f
                  {:
                    RESULT = new Integer(e.intValue() - f.intValue());
                  :}
                  |
                  factor:n
                  {:
                    RESULT = n; 
                  :}
                  ;

factor        ::=  factor:f MULT termino:e
                  {:
                    RESULT = new Integer(f.intValue() * e.intValue());
                  :}
                  |
                  termino:t
                  {:
                    RESULT = t;
                  :}
                  ;

termino       ::=  LPAREN expr:e RPAREN
                  {:
                    RESULT = e;
                  :}
                  |
                  INT:e
                  {:
                    RESULT = e;
                  :}
                  ; 
*/