// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import java.io.FileReader;
import java.io.BufferedReader;
/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s){ this.s=s; }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;
    
    @Override
    public void syntax_error(Symbol current_token) {
      syntaxErrs += 1;
      System.out.println(
        "SYNTAX ERROR AT LINE " + (current_token.left+1) + " COLUMN " + current_token.right +
          " VALUE: " + current_token.value + " - ");
    }

    public void initParser(String file){
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    new Lexer(br));
            Object result = codeParser.parse().value;
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            //ex.printStackTrace();
        }
    }

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    INTARR, CHARARR;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE;
terminal    RETURN, MAIN, FUNC;
terminal    READ, PRINT;

// Boolean.
terminal    TRUE, FALSE;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Literals.
terminal    INTLIT, FLOATLIT;
terminal    CHARLIT, STRINGLIT;
// Identifiers.
terminal    ID;

/* Non terminals */
non terminal    ini;       
//non terminal    Integer  expr;      
non terminal    main, function, functionInv;    
non terminal    codeBlock;
non terminal    varCreation;
non terminal    printFunction, readFunction;
non terminal    expression, mathExpression, logRelExpression;
non terminal    unaryExpression;
non terminal    parameters, parametersInv;
non terminal    literal, numLiteral, lettersLiteral, boolLit;
non terminal    logicalExpression, logicalExpr, relationalExpression;
non terminal    mathOperand, relationalOperand, logicalOperand;
non terminal    mathOperator, relationalOperator, logicalOperator;
//non terminal  expr, factor, termino;
// Precedence and associativity declarations

// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          main | function
          |
          main ini
          |
          function ini
          ;

// ---------- main function (no params, MAIN is recognized as main()) ----------
main ::= 
          INT MAIN LCURLY RCURLY
          |
          INT MAIN LCURLY codeBlock RCURLY
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.
  The lexeme is "functionName(", that is why RPAREN is missing. */
function ::=
          INT FUNC RPAREN LCURLY codeBlock RCURLY
          |
          CHAR FUNC RPAREN LCURLY codeBlock RCURLY
          |
          BOOL FUNC RPAREN LCURLY codeBlock RCURLY
          |
          INT FUNC parameters RPAREN LCURLY codeBlock RCURLY
          |
          CHAR FUNC parameters RPAREN LCURLY codeBlock RCURLY
          |
          BOOL FUNC parameters RPAREN LCURLY codeBlock RCURLY
          ;
functionInv ::=
          FUNC RPAREN
          |
          FUNC parametersInv RPAREN
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID COMMA parameters
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT | STRINGLIT | boolLit | ID
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          boolLit COMMA parametersInv
          |
          ID COMMA parametersInv
          ;
// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          expression
          |
          expression codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreation ::=   
          INT ID | INT ID EQ INTLIT | INT ID EQ functionInv
          |
          FLOAT ID | FLOAT ID EQ FLOATLIT
          |
          CHAR ID | CHAR ID EQ CHARLIT | CHAR ID EQ functionInv
          |
          BOOL ID | BOOL ID EQ boolLit
          |
          //ARRAY ID | ARRAY ID 
          |
          STRING ID | STRING ID EQ STRINGLIT
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT LPAREN INTLIT RPAREN
          |
          PRINT LPAREN FLOATLIT RPAREN
          |
          PRINT LPAREN CHARLIT RPAREN
          |
          PRINT LPAREN STRINGLIT RPAREN
          |
          PRINT LPAREN ID RPAREN
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          READ
          ;
// ---------- Expressions ----------
expression ::=
          mathExpression
          |
          unaryExpression HASH
          |
          logRelExpression HASH
          |
          varCreation HASH
          | 
          printFunction HASH
          | 
          readFunction HASH
          ;
literal ::=
          numLiteral | lettersLiteral | boolLit
          ;
numLiteral ::=
          INTLIT | FLOATLIT
          ;
lettersLiteral ::=
          CHARLIT | STRINGLIT
          ;
boolLit ::=
          TRUE | FALSE
          ;
unaryExpression ::=
          ID PADD | ID PSUBS 
          |
          INTLIT PADD | INTLIT PSUBS 
          |
          FLOATLIT PADD | FLOATLIT PSUBS 
          ;
mathExpression ::=
          mathOperand
          |
          mathOperand mathOperator mathExpression
          ;
logRelExpression ::=
          logicalExpression | relationalExpression
          ;
relationalExpression ::=
          relationalOperand relationalOperator relationalOperand
          ;
logicalExpression ::=
          logicalOperand logicalOperator logicalExpr //HASH
          ;
logicalExpr ::=
          logicalOperand
          |
          logicalOperand logicalOperator logicalExpr
          ;
// ---------- Operands and operators ----------
mathOperand ::=
          literal | functionInv | ID
          ;
relationalOperand ::=
          mathOperand | LPAREN mathExpression RPAREN
          ;
logicalOperand ::=
          ID | boolLit | functionInv | LPAREN relationalExpression RPAREN
          ;
mathOperator ::=
          ADD | SUBS | DIV | MULT | EXP | MOD
          ;
relationalOperator ::=
          GTE | GT | LTE | LT
          ;
logicalOperator ::=
          AND | OR | EQEQ | NOT
          ;