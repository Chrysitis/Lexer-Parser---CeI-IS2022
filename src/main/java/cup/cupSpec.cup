// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import java.io.FileReader;
import java.io.BufferedReader;
/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s){ this.s=s; }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;

    public void syntax_error(Symbol current_token) {
      syntaxErrs += 1;
      System.out.println(
        "SYNTAX ERROR AT LINE " + (current_token.left+1) + " COLUMN " + current_token.right +
          " VALUE: " + current_token.value + " - ");
    }

    public void initParser(String file){
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    new Lexer(br));
            Object result = codeParser.parse().value;
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            //ex.printStackTrace();
        }
    }

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE;
terminal    RETURN, MAIN, FUNC;
terminal    READ, PRINT;

// Boolean.
terminal    TRUE, FALSE;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Number literals.
terminal INTLIT, FLOATLIT;
terminal CHARLIT, STRINGLIT;

terminal ID;


/* Non terminals */
non terminal          ini;       // Starting point...
non terminal Integer  expr;       // used to store evaluated subexpressions
non terminal main, function;      // main and other functions.
non terminal codeBlock;
non terminal varCreation, varCreationAsign;
non terminal parameters;
//non terminal expr, factor, termino;
// Precedence and associativity declarations

// The grammar.
start with ini;
ini ::=
          main
          |
          main function
          |
          function main
          ;

main ::= 
          INT MAIN LPAREN RPAREN LCURLY RCURLY
          |
          INT MAIN LPAREN RPAREN LCURLY codeBlock RCURLY
          ;
function ::=
          INT ID LPAREN RPAREN LCURLY RCURLY
          |
          CHAR ID LPAREN RPAREN LCURLY RCURLY
          |
          BOOL ID LPAREN RPAREN LCURLY RCURLY
          ;

parameters ::= 
          INT ID
          |
          CHAR ID
          |
          BOOL ID
          |
          ARRAY ID
          |
          STRING ID
          ;

codeBlock ::=
          varCreation | varCreationAsign
          |
          varCreation codeBlock 
          |
          varCreationAsign codeBlock 
          ;
// ---------- variable creation ----------
varCreation ::=   
          INT ID HASH
          |
          CHAR ID HASH
          |
          BOOL ID HASH
          |
          ARRAY ID HASH
          |
          STRING ID HASH
          ;
varCreationAsign ::=
          INT ID EQ INTLIT HASH
          |
          BOOL ID EQ TRUE HASH
          |
          BOOL ID EQ FALSE HASH
          | 
          CHAR ID EQ CHARLIT HASH 
          | 
          FLOAT ID EQ FLOATLIT HASH
          |
          STRING ID EQ STRINGLIT HASH
          //|
          //ARRAY ID EQ ARRAYLIT HASH
          ;
/*
    expr_list ::= expr_list expr_part
                  |
                  expr_part
                  ;

   expr_part ::= expr:e
                  {:
                    System.out.println(" = " + e); 
                  :} 
                  HASH
                 ;
                  
        

   expr      ::=  expr:e ADD factor:f
                  {:
                    RESULT = new Integer(e.intValue() + f.intValue());
                  :}
                  |
                  expr:e SUBS factor:f
                  {:
                    RESULT = new Integer(e.intValue() - f.intValue());
                  :}
                  |
                  factor:n
                  {:
                    RESULT = n; 
                  :}
                  ;

factor        ::=  factor:f MULT termino:e
                  {:
                    RESULT = new Integer(f.intValue() * e.intValue());
                  :}
                  |
                  termino:t
                  {:
                    RESULT = t;
                  :}
                  ;

termino       ::=  LPAREN expr:e RPAREN
                  {:
                    RESULT = e;
                  :}
                  |
                  INT:e
                  {:
                    RESULT = e;
                  :}
                  ; 
*/