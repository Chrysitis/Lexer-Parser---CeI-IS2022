// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import fileManager.*;
import java.util.Map;
import symbolTable.*;
import java.util.ArrayList;
import org.apache.commons.lang3.math.NumberUtils;

/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s, SymbolTableManager manager, Lexer lexer){ 
      this.s=s; 
      this.stManager = manager;
      this.lexer = lexer;
      }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;
    public SymbolTableManager stManager;
    public SymbolTable currentSymbolTable = null;
    public String currentFunction;
    public Lexer lexer;

    @Override
    public void syntax_error(Symbol current_token) {
      String errInfo = "SYNTAX ERROR AT LINE " + (current_token.left) + " COLUMN " 
        + (current_token.right) + " VALUE: " + current_token.value + " - ";
      System.out.println(errInfo); 
      reportErrToFile(errInfo);
      this.syntaxErrs += 1;
    }    

    private void reportErrToFile(String info){
      FileManager fileManager = new FileManager("C:/Users/chris/Documents/NetBeansProjects/CeI-PYI/src/main/java/symbolTable/Tokens.txt");
      fileManager.writeToFile(info);
    }

    // Converts String to Integer.
    private Integer convertToInteger(Object val){
      //System.out.println("**********************VALUE CONVERTING TO INT: " + val);
      return Integer.parseInt(val.toString());
    }
    // Converts String to Float.
    private Float convertToFloat(Object val){
      //System.out.println("**********************VALUE CONVERTING TO FLOAT: " + val);
      return Float.parseFloat(val.toString());
    }
    public void initParser(Lexer lexer){
        //Object result;
        try {
            //BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    s, lexer.getSymbolTableManager(), lexer);
            Object result = codeParser.parse().value;
            //result = codeParser.parse().value;
            System.out.println("THE PARSER RESULT IS: " + result);
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            //System.err.println("AT THIS TIME RESULT IS: " + result);
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            ex.printStackTrace();
        }
    }
    
  public void printSymbolTable() {
    int index = 0;
    int size = stManager.getSymbolTables().size();
    for(int i = 0; i < size; i++) {
      System.out.println();
      String funcName = stManager.getSymbolTables().get(i).getFuncName();
      String funcType = stManager.getSymbolTables().get(i).getFuncType();
      String funcReturn = stManager.getSymbolTables().get(i).getReturnVal();
      ArrayList<String> funcParams = stManager.getSymbolTables().get(i).getFuncParams();
      int funcScope = stManager.getSymbolTables().get(i).getTableScope();
      Map<String,ArrayList<String>> current = stManager.getSymbolTables().get(i).getSymbolTable();
      System.out.println("FUNCTION \t SCOPE \t\t VARIABLES \t ATTRIBUTES \t\t FUNC RETURN TYPE \t\t FUNC RETURN VAL \t\t FUNC PARAMS");
      current.forEach(
        (k, v) -> System.out.println(funcName + "\t\t " + funcScope +" \t\t " + k + " \t\t " + v
          + "\t\t\t " + funcType + "\t\t\t " + funcReturn + "\t\t\t\t " + funcParams 
          + "\n_________________________________________________________________________________________________________________________________________________________")
      );
    } 
  }


  // Updates the symbol table entries for type and value for the given id.
  public void updateIntegerSymbolTable(Object id, Object type, Integer val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? Integer.toString(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateFloatSymbolTable(Object id, Object type, Float val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? Float.toString(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateCharacterSymbolTable(Object id, Object type, Character val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? String.valueOf(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateStringSymbolTable(Object id, Object type, String val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? val : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateBooleanSymbolTable(Object id, Object type, String val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? val : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // To manage variable scope and presence.
  public void updateCurrentFunction(Object name) {
    //System.out.println("CURRENT FUNCTION IS: " + name.toString());
    this.currentFunction = name.toString();
  }

  public String getIdValue(String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String res = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        //System.out.println("CURRENT FUNCTION IS: " + this.currentFunction + "ST FUNCTION IS: " + st.getFuncName());
        if(st.getTableScope() != 0){
          res = st.getSymbolTable().get(id).get(1);
          return res;
        }
      }
    }
    return res;
  }

  // id means refers to variale id and type refers to either variable or function.
  // dataType refers to the required data type for the id to be valid in any operation.
  // Validates the existance of the given id, the scope and value type.
  
public String validateId(String id, String type , String dataType) {    
    // First, validates the existance and scope.
    String result;
    if(validateScope(id)) {
      result = getIdValue(id);
      //System.out.println("RESULT OF ID VALIDATION IS: " + result);
    } else {
      result = "-e1";
    }
    return result;
}

  public String validateFunc(String func, String funcType) {
    
    // First, validates the existance and scope.
    String result = "";
    String res = "";
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    SymbolTable st;
    int limit = sTables.size() - 1;
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i); 
      if(st.getTableScope() == 1) {
        //System.out.println("COMPARING " + st.getFuncName() + " TO " + func);
        if(st.getFuncName().equals(func)) {
          //System.out.println("COMPARING TYPES " + st.getFuncType() + " TO " + funcType);
          if(st.getFuncType().equals(funcType)) {
            res = st.getReturnVal();
            if(!NumberUtils.isParsable(res)) {
                result = getValueFromFunc(func, res);
                return result;
              } else {
                result = st.getReturnVal();
                }
          } else {
            result = "-e2";
            return result;
          }
        }
        result = "-e4";
      }
    }
    return result;
}

  public String getValueFromFunc(String func, String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String result = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getTableScope() != 0 && st.getFuncName().equals(func)) {        
        result = st.getSymbolTable().get(id).get(1);
        return result;
      }
    }

    return result;
  } 
  public boolean validateScope(String id) {
    boolean result = false;
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    SymbolTable st;
    int limit = sTables.size() - 1;
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        if (st.getSymbolTable().containsKey(id)) {
          int currentScope = lexer.scope;
          // Checks for current scope.
          if (st.getTableScope() < currentScope) {
            //System.out.println("LA VARIABLE EXISTE EN SCOPE ARRIBA");
            result = true;
          } // Checks if it exists on higher scopes. 
          else if (st.getTableScope() == currentScope) {
            //System.out.println("LA VARIABLE EXISTE EN SCOPE PRESENTE");
            result = true;
          } else {
            result = false;
          }
        }
      }
    }
    return result;
  }

  // Reports semantic err according to the number received.
  // -e1 means no such id or no such id in the current scope.
  // -e2 means type conflict.
  // -e3 means id has null value.
  // -e4 means no such function.
  public String reportSemanticErr(String lexeme, String errType) {
    String err = "";
    if(errType.equals("-e1")) {
      err = "--------------- SEMANTIC ERR: NO SUCH VARIABLE " + lexeme + " CREATED OR IN SCOPE. ---------------";
    } else if(errType.equals("-e2")) {
      err = "--------------- SEMANTIC ERR: FUNCTION OR VARIABLE NAMED" + lexeme + " DATA TYPE CONFLICT. ---------------";
    } else if(errType.equals("-e4")) {
      err = "--------------- SEMANTIC ERR: NO SUCH FUNCTION NAMED " + lexeme + " EXISTS. ---------------";
      }
    return err;
}

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    INTARR, CHARARR;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE, DEFAULT;
terminal    RETURN, MAIN;
terminal Object         FUNC;
terminal    READ, PRINT;
terminal    COMMENT;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA, COLON;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Boolean.
terminal Boolean        TRUE, FALSE;

// Literals.
terminal Object         INTLIT;
terminal Object         FLOATLIT;
terminal Object         CHARLIT;
terminal String         STRINGLIT;
terminal    ARRAYLIT;

// Identifiers.
terminal Object         ID;

/* Non terminals */
non terminal    ini;       
non terminal    main, function;
non terminal Object     functionInv;    
non terminal    codeBlock;
non terminal    varAsign;
non terminal    printFunction, readFunction;
non terminal    expression;
non terminal    logRelExpression;
non terminal Object     unaryExpression;
non terminal    parameters, parametersInv;
non terminal    literal;
non terminal    numLiteral;
non terminal    lettersLiteral;
non terminal    logicalExpression, logicalExpr, relationalExpression;
non terminal    relationalOperand, logicalOperand;
non terminal    mathOperator, relationalOperator, logicalOperator;
non terminal    if, while, for, switch, switchBody;
non terminal    zero;
non terminal    arrayAccess, arrayValModification;
non terminal    return;
non terminal Object     varCreationAsign;
non terminal Object     mathExpression;
non terminal    mathOperand;
non terminal Object     intMathExpression;
non terminal Float      floatMathExpression;
non terminal Character  charCreationAssign;
non terminal Object     intCreationAssign;
non terminal Object      floatCreationAssign;
non terminal String     stringCreationAssign;
non terminal Boolean    boolCreationAssign;
non terminal Integer    intMathOperand;
non terminal Float      floatMathOperand;
non terminal Boolean    boolLit;
non terminal Object     intTerm, intFactor;
non terminal Float      floatTerm, floatFactor;
non terminal Object     intVarAsign;
non terminal Object    intUnaryExpression;
non terminal Float      floatUnaryExpression;


// Precedence and associativity declarations
precedence left ADD, SUBS; 
precedence left MULT, DIV;
// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          function ini
          |
          main
          ;

// ---------- main function (no params, MAIN is recognized as main()) ----------
main ::= 
          INT MAIN:name 
            {: 
              updateCurrentFunction(name); 
              //System.out.println("CURRENT FUNC IS: " + currentFunction); 
            :} 
          LCURLY codeBlock RCURLY
          ;
return ::=
          RETURN ID | RETURN INTLIT | RETURN FLOATLIT | RETURN CHARLIT | RETURN STRING
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.
  The lexeme is "functionName(", that is why RPAREN is missing. */
function ::=
          INT FUNC:name {: updateCurrentFunction(name);:} RPAREN LCURLY codeBlock RCURLY
          |
          CHAR FUNC:name {: updateCurrentFunction(name);:} RPAREN LCURLY codeBlock RCURLY
          |
          FLOAT FUNC:name {: updateCurrentFunction(name);:} RPAREN LCURLY codeBlock RCURLY
          |
          INT FUNC:name {: updateCurrentFunction(name);:} parameters RPAREN LCURLY codeBlock RCURLY
          |
          CHAR FUNC:name {: updateCurrentFunction(name);:} parameters RPAREN LCURLY codeBlock RCURLY
          |
          FLOAT FUNC:name {: updateCurrentFunction(name);:} parameters RPAREN LCURLY codeBlock RCURLY
          ;
functionInv ::=
          FUNC:name RPAREN 
            {:
              RESULT = name;
            :}
          |
          FUNC parametersInv RPAREN
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID:id {: System.out.println("PARAM ES: " + id); :} | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID:param COMMA parameters 
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT {: System.out.println("PARAM ES: "); :} | STRINGLIT | boolLit | ID | functionInv
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          boolLit COMMA parametersInv
          |
          ID COMMA parametersInv
          |
          functionInv COMMA parametersInv
          ;
// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          expression | COMMENT
          |
          expression codeBlock
          |
          COMMENT codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreationAsign ::=   
          intCreationAssign
          |
          floatCreationAssign
          |
          charCreationAssign
          |
          stringCreationAssign
          |
          boolCreationAssign
          |
          INTARR INTLIT RSQUARE ID | INTARR INTLIT RSQUARE ID EQ ARRAYLIT
          |
          CHARARR INTLIT RSQUARE ID | CHARARR INTLIT RSQUARE ID EQ ARRAYLIT
          ;
intCreationAssign ::=
          INT:dType ID:id 
            {:
              RESULT = null;
              //System.out.println("EL ID DE INT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateIntegerSymbolTable(id, dType, null);
            :} 
          | 
          INT:dType ID:id EQ intMathExpression:val
            {:
            //System.out.println("ENTRO A INT:dType ID:id EQ intMathExpression:val");
              if(val.getClass().toString().equals("class java.lang.Integer")) {
                RESULT = val;
                //System.out.println("EL ID DE INT ES: " + id);
                //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
                updateIntegerSymbolTable(id, dType, convertToInteger(RESULT));
              } else {
              System.out.println("*** SEMANTIC ERR *** ID: " + id + " ES INT ES Y ASIGNO FLOAT.");
              }
            :}
          | 
          INT:dType ID:id EQ floatMathExpression:val
            {:
              RESULT = null;
              System.out.println("*** SEMANTIC ERR *** ID ES INT Y ASIGNO FLOAT.");
            :}
          ;
floatCreationAssign ::=
          FLOAT:dType ID:id
            {:
              RESULT = null;
              System.out.println("EL ID DE FLOAT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateFloatSymbolTable(id, dType, null);
            :}
          |
          FLOAT:dType ID:id EQ intMathExpression:val
            {:
              RESULT = val;
              //System.out.println("EL ID DE FLOAT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateFloatSymbolTable(id, dType, convertToFloat(RESULT));
            :}
          ;
charCreationAssign ::=
          CHAR:dType ID:id
            {:
              RESULT = null;
              System.out.println("EL ID DE CHARLIT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateCharacterSymbolTable(id, dType, RESULT);
            :}
          |
          CHAR:dType ID:id EQ CHARLIT:val
            {:
              RESULT = Character.valueOf(val.toString().charAt(1));
              System.out.println("EL ID DE CHARLIT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateCharacterSymbolTable(id, dType, RESULT); 
            :}
          |
          CHAR:dType ID:id EQ functionInv:val
            {:
              System.out.println("ENTRO A functionInv PARA CHAR = " + val.toString());
              String res = validateFunc(val.toString(), "char");
              if (!res.contains("-e")) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = res.charAt(0);
                updateCharacterSymbolTable(id, dType, RESULT);  
              } else {
                System.out.println(reportSemanticErr(val.toString(), res));
                RESULT = null;
              }
           :}
           |
          CHAR:dType ID:id EQ ID:val
            {:
              System.out.println("ENTRO A functionInv PARA CHAR = " + val.toString());
              String res = validateId(val.toString(), "char", "id");
              if (!res.contains("-e")) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = res.charAt(0);
                updateCharacterSymbolTable(id, dType, RESULT);  
              } else {
                System.out.println(reportSemanticErr(val.toString(), res));
                RESULT = null;
              }
           :}
          ;
stringCreationAssign ::=
          STRING:dType ID:id 
            {:
              RESULT = null;
              System.out.println("EL ID DE STRING ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateStringSymbolTable(id, dType, RESULT); 
            :}
          | 
          STRING:dType ID:id EQ STRINGLIT:val
            {:
              RESULT = val;
              System.out.println("EL ID DE STRING ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateStringSymbolTable(id, dType, RESULT); 
            :}
          ;
boolCreationAssign ::=
          BOOL:dType ID:id 
            {:
              RESULT = null;
              System.out.println("EL ID DE BOOL ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              //updateBooleanSymbolTable(id, dType, null.toString());
              updateBooleanSymbolTable(id, dType, "null"); 
            :} 
          | 
          BOOL:dType ID:id EQ boolLit:val
            {:
              RESULT = val;
              System.out.println("EL ID DE BOOL ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateBooleanSymbolTable(id, dType, RESULT.toString()); 
            :} 
          | 
          BOOL ID EQ logicalExpression
          ;
varAsign ::=
          intVarAsign
          ;
intVarAsign ::=
          ID:id EQ intMathExpression:val
            {:
              RESULT = val;
              System.out.println("ENTRO A intVarAsign");
              System.out.println("EL ID DE INT ES: " + id);
              System.out.println(" --> LA NUEVA ASIGNACION DE " + id + " ES: " + RESULT);
              if(lexer.idTypeExamination.equals("int")) {
                updateIntegerSymbolTable(id, "int", convertToInteger(val.toString()));
              }else if(lexer.idTypeExamination.equals("float")) {
                updateFloatSymbolTable(id, "float", convertToFloat(val.toString()));
              }
            :} 
          ;
arrayAccess ::=
          ID LSQUARE INTLIT RSQUARE
          |
          ID LSQUARE ID RSQUARE
          ;
arrayValModification ::=
          //ID LSQUARE INTLIT RSQUARE EQ INTLIT
          //|
          //ID LSQUARE INTLIT RSQUARE EQ ID
          //|
          ID LSQUARE INTLIT RSQUARE EQ mathExpression
          |
          //ID LSQUARE ID RSQUARE EQ INTLIT
          //|
          //ID LSQUARE ID RSQUARE EQ ID
          //|
          ID LSQUARE ID RSQUARE EQ mathExpression
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT LPAREN INTLIT RPAREN
          |
          PRINT LPAREN FLOATLIT RPAREN
          |
          PRINT LPAREN CHARLIT RPAREN
          |
          PRINT LPAREN STRINGLIT RPAREN
          |
          PRINT LPAREN ID RPAREN
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          READ
          ;
// ---------- Expressions ----------
expression ::=
          logRelExpression HASH
          |
          varCreationAsign HASH
          |
          varAsign HASH
          |
          printFunction HASH
          | 
          readFunction HASH
          |
          arrayValModification HASH
          |
          if | while | for  
          |
          return HASH
          |
          error HASH
          ;
boolLit ::=
          TRUE {: RESULT = true; :} | FALSE {: RESULT = false; :}
          ;
intUnaryExpression ::=
          ID:id PADD
            {:
              String res;
              Object eval;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else {
                res = validateId(id.toString(), "float", "id");
              }
              if (NumberUtils.isParsable(res)) {
                if(lexer.idTypeExamination.equals("int")) { 
                  res = validateId(id.toString(), "int", "id");
                  eval = convertToInteger(res) + 1;
                  RESULT = eval;
                } else {
                  res = validateId(id.toString(), "float", "id");
                  eval = convertToFloat(res) + 1.0;       
                  RESULT = eval;          
                }              
              } else {
                System.out.println(reportSemanticErr(id.toString(), res));
              }
            :}
          | 
          ID:id PSUBS 
            {:
              String res;
              Object eval;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else {
                res = validateId(id.toString(), "float", "id");
              }
              if (NumberUtils.isParsable(res)) {
                if(lexer.idTypeExamination.equals("int")) { 
                  res = validateId(id.toString(), "int", "id");
                  eval = convertToInteger(res) - 1;
                  RESULT = eval;
                } else {
                  res = validateId(id.toString(), "float", "id");
                  eval = convertToFloat(res) - 1.0;       
                  RESULT = eval;          
                }              
              } else {
                System.out.println(reportSemanticErr(id.toString(), res));
              }
            :}
          ;
floatUnaryExpression ::=
          INTLIT PADD | INTLIT PSUBS 
          |
          FLOATLIT PADD | FLOATLIT PSUBS 
          ;
mathExpression ::=
          intMathExpression:val
            {:
              System.out.println("EL RESULTADO FINAL ES: " + val);
            :}
          |
          floatMathExpression
          ;
intMathExpression ::=
          intMathExpression:op1 ADD intFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(op1) + convertToInteger(op2);
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(op1) + convertToFloat(op2);
              }
            :}
          |
          intMathExpression:op1 SUBS intFactor:op2
            {:
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(op1) - convertToInteger(op2);
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(op1) - convertToFloat(op2);
              }
            :}
          |
          intFactor:val
            {:
              //System.out.println("ENTRO A intFactor:val = " + val);
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(val.toString());
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(val.toString()); 
              }            
            :}
          ;
intFactor ::=
          intFactor:f MULT intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(f.toString()) * convertToInteger(t.toString());
                val = iRes;
                RESULT = val;
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(f.toString()) * convertToFloat(t.toString()); 
                val = fRes;
                RESULT = val;
              }
            :}
          |
          intFactor:f DIV intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(f.toString()) / convertToInteger(t.toString());
                val = iRes;
                RESULT = val; 
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(f.toString()) / convertToFloat(t.toString());
                val = fRes;
                RESULT = val;
              }
            :}
          |
          intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(t.toString()); 
                val = iRes;
                RESULT = val;
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(t.toString()); 
                val = fRes;
                RESULT = val;
              }
            :}
          ;
intTerm ::=
          INTLIT:n
            {: 
              if(lexer.idTypeExamination.equals("int")) {
              //System.out.println("ENTRO A INTLIT = " + n);
              RESULT = n;
              //RESULT = convertToInt(n.toString()); 
              }
            :}
          |
          FLOATLIT:n
            {: 
              if(lexer.idTypeExamination.equals("float")) {
              //System.out.println("ENTRO A FLOATLIT = " + n);
              RESULT = n;
              //RESULT = convertToFloat(n.toString()); 
              }
            :}
          |
          ID:id
            {:
              //System.out.println("ENTRO A ID = " + id);
              Object val = 0;
              String res;
              System.out.println("TYPE ID EXAM IS: " + lexer.idTypeExamination);
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else {
                res = validateId(id.toString(), "float", "id");
              }
              System.out.println("VALIDATION AT FINAL IS: " + res);
              System.out.println("IS VALIDATION PARSABLE: " + NumberUtils.isParsable(res));
              if (NumberUtils.isParsable(res)) {
                val = res;
                RESULT = val;
              } else {
                  System.out.println(reportSemanticErr(id.toString(), res));
                  //val = res;
                  RESULT = 0;
                //RESULT = 0;
              }
            :}
            |
          functionInv:n
            {: 
              Object val = 0;
              System.out.println("ENTRO A functionInv = " + n.toString());
              String res;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateFunc(n.toString(), "int");
              } else {
                res = validateFunc(n.toString(), "float");
              }
              if (NumberUtils.isParsable(res)) {
                //System.out.println("ENTRO A PARSABLE");
                val = res;
                RESULT = val;
              } else {
                System.out.println(reportSemanticErr(n.toString(), res));
                RESULT = val;
              }
            :}
            |
            intUnaryExpression:val
              {:
                RESULT = val;
              :}
          ;
/*
floatMathExpression ::=
          floatMathExpression:op1 ADD floatFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 + op2;
            :}
          |
          floatMathExpression:op1 SUBS floatFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 - op2;
            :}
          |
          intFactor:val
            {:
              RESULT = convertToFloat(val);
            :}
          ;

floatFactor ::=
          floatFactor:f MULT floatTerm:t
            {: 
              RESULT = convertToFloat(f) * convertToFloat(t); 
            :}
          |
          floatFactor:f DIV floatTerm:t
            {: 
              RESULT = convertToFloat(f) / convertToFloat(t); 
            :}
          |
          floatTerm:t
            {: 
              RESULT = convertToFloat(t); 
            :}
          ;
floatTerm ::=
          FLOATLIT:n
            {: 
              RESULT = convertToFloat(n); 
            :}
          |
          ID:id
            {:
              //RESULT = 99;
              //System.out.println("ENTRO A ID = " + id);
              String validation = validateId(id.toString(), "float", "id");
              //System.out.println("VALIDATION AT FINAL IS: " + validation);
              if (NumberUtils.isParsable(validation)) {
                RESULT = convertToFloat(validation); 
              } else {
                System.out.println(reportSemanticErr(id.toString(), validation));
                RESULT = 0;
              }
            :}
            |
          functionInv:n
            {: 
              System.out.println("ENTRO A functionInv = " + n.toString());
              String res = validateFunc(n.toString(), "float");
              if (NumberUtils.isParsable(res)) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = convertToInteger(res);
              } else {
                System.out.println(reportSemanticErr(n.toString(), res));
                RESULT = 0;
              }
            :}
            |
            intUnaryExpression:val
              {:
                if(val.getClass().toString().equals("class java.lang.Float")) {
                  RESULT = val;
                } else {
                  System.out.println(reportSemanticErr("", "-e2"));
                }
                
              :}

          ;*/
logRelExpression ::=
          logicalExpression | relationalExpression
          ;
relationalExpression ::=
          relationalOperand relationalOperator relationalOperand
          ;
logicalExpression ::=
          logicalOperand logicalOperator logicalExpr //HASH
          ;
logicalExpr ::=
          logicalOperand
          |
          logicalOperand logicalOperator logicalExpr
          ;
// ---------- Operands and operators ----------
mathOperand ::=
          //unaryExpression | ID | functionInv | 
          intMathOperand:val {: RESULT = val; :}
          | 
          floatMathOperand:val {: RESULT = val; :}
          ;
intMathOperand ::=
          INTLIT:val {: RESULT = convertToInteger(val); :} //| arrayAccess  
          ;
floatMathOperand ::=
          FLOATLIT:val {: RESULT = convertToFloat(val); :}
          ;
relationalOperand ::=
          mathOperand | LPAREN mathExpression RPAREN
          ;
logicalOperand ::=
          ID | boolLit | functionInv | LPAREN relationalExpression RPAREN
          ;
mathOperator ::=
          ADD | SUBS | DIV | MULT | EXP | MOD
          ;
relationalOperator ::=
          GTE | GT | LTE | LT
          ;
logicalOperator ::=
          AND | OR | EQEQ | NOT
          ;
// ---------- IF THEN ELSE structure ----------

if ::=  // Add rule to make it work with a boolean literal: true/false
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY
        |
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY ELSE LCURLY codeBlock RCURLY
        ;
// ---------- WHILE structure ----------
while ::=
        WHILE LPAREN logRelExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- FOR structure ----------
for ::=
        FOR LPAREN INT ID EQ zero COMMA logRelExpression COMMA unaryExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- SWITCH structure ----------
/*
switch ::=
        SWITCH LPAREN ID RPAREN LCURLY switchBody RCURLY
        ;
switchBody ::=
        CASE INTLIT COLON codeBlock | DEFAULT
        |
        CASE INTLIT COLON codeBlock switchBody
        ;
*/
zero ::=
        INTLIT
        ;