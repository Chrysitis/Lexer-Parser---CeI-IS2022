// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import java.io.FileReader;
import java.io.BufferedReader;
import fileManager.*;

/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s){ this.s=s; }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;

    @Override
    public void syntax_error(Symbol current_token) {
      String errInfo = "SYNTAX ERROR AT LINE " + (current_token.left) + " COLUMN " 
        + (current_token.right) + " VALUE: " + current_token.value + " - ";
      System.out.println(errInfo); 
      reportErrToFile(errInfo);
      this.syntaxErrs += 1;
    }    

    private void reportErrToFile(String info){
      FileManager fileManager = new FileManager("C:/Users/chris/Documents/NetBeansProjects/CeI-PYI/src/main/java/symbolTable/Tokens.txt");
      fileManager.writeToFile(info);
    }

    private Integer convertToInteger(Object val){
      return Integer.parseInt(val.toString());
    }
    private Float convertToFloat(Object val){
      return Float.parseFloat(val.toString());
    }
    public void initParser(){
        //Object result;
        try {
            //BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    s);
            Object result = codeParser.parse().value;
            //result = codeParser.parse().value;
            System.out.println("THE PARSER RESULT IS: " + result);
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            //System.err.println("AT THIS TIME RESULT IS: " + result);
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            ex.printStackTrace();
        }
    }

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    INTARR, CHARARR;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE, DEFAULT;
terminal    RETURN, MAIN, FUNC;
terminal    READ, PRINT;
terminal    COMMENT;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA, COLON;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Boolean.
terminal Boolean        TRUE, FALSE;

// Literals.
terminal Object         INTLIT;
terminal Object         FLOATLIT;
terminal Object         CHARLIT;
terminal String         STRINGLIT;
terminal    ARRAYLIT;

// Identifiers.
terminal String ID;

/* Non terminals */
non terminal    ini;       
non terminal    main, function, functionInv;    
non terminal    codeBlock;
non terminal    varAsign;
non terminal    printFunction, readFunction;
non terminal    expression;
non terminal    logRelExpression;
non terminal    unaryExpression;
non terminal    parameters, parametersInv;
non terminal    literal;
non terminal    numLiteral;
non terminal    lettersLiteral;
non terminal    logicalExpression, logicalExpr, relationalExpression;
non terminal    relationalOperand, logicalOperand;
non terminal    mathOperator, relationalOperator, logicalOperator;
non terminal    if, while, for, switch, switchBody;
non terminal    zero;
non terminal    arrayAccess, arrayValModification;
non terminal    return;
non terminal    varCreationAsign;
non terminal Object   mathExpression;
non terminal    mathOperand;
non terminal Integer intMathExpression;
non terminal Float   floatMathExpression;
non terminal Character  charCreationAssign;
non terminal Integer    intCreationAssign;
non terminal Float      floatCreationAssign;
non terminal String     stringCreationAssign;
non terminal Boolean    boolCreationAssign;
non terminal Integer    intMathOperand;
non terminal Float      floatMathOperand;
non terminal Boolean    boolLit;
non terminal Integer    intTerm, intFactor;
non terminal Float      floatTerm, floatFactor;


// Precedence and associativity declarations
precedence left ADD, SUBS; 
precedence left MULT, DIV; 
// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          main | function
          |
          main ini
          |
          function ini
          ;

// ---------- main function (no params, MAIN is recognized as main()) ----------
main ::= 
          INT MAIN LCURLY return HASH RCURLY 
          |
          INT MAIN:m LCURLY codeBlock return HASH RCURLY {:System.out.println("ESTE ES EL MAIN: " + m);:}
          ;
return ::=
          RETURN ID | RETURN INTLIT | RETURN FLOATLIT | RETURN CHARLIT
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.
  The lexeme is "functionName(", that is why RPAREN is missing. */
function ::=
          INT FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          CHAR FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          FLOAT FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          INT FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          |
          CHAR FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          |
          FLOAT FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          ;
functionInv ::=
          FUNC RPAREN
          |
          FUNC parametersInv RPAREN
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID:id {: System.out.println("PARAM ES: " + id); :} | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID:param COMMA parameters 
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT {: System.out.println("PARAM ES: "); :} | STRINGLIT | boolLit | ID | functionInv
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          boolLit COMMA parametersInv
          |
          ID COMMA parametersInv
          |
          functionInv COMMA parametersInv
          ;
// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          expression | COMMENT
          |
          expression codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreationAsign ::=   
          intCreationAssign
          |
          floatCreationAssign
          |
          charCreationAssign
          |
          stringCreationAssign
          |
          boolCreationAssign
          |
          INTARR INTLIT RSQUARE ID | INTARR INTLIT RSQUARE ID EQ ARRAYLIT
          |
          CHARARR INTLIT RSQUARE ID | CHARARR INTLIT RSQUARE ID EQ ARRAYLIT
          ;
intCreationAssign ::=
          INT ID 
          | 
          INT ID:id EQ intMathExpression:val
            {:
              System.out.println("EL ID DE INT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
            :}
          ;
floatCreationAssign ::=
          FLOAT ID:id
            {:
              System.out.println("EL ID DE FLOAT ES: " + id);
            :}
          |
          FLOAT ID:id EQ floatMathExpression:val
            {:
              System.out.println("EL ID DE FLOAT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
            :}
          ;
charCreationAssign ::=
          CHAR ID:id
            {:
              RESULT = null;
              System.out.println("EL ID DE CHARLIT ES: " + id);
            :}
          |
          CHAR ID:id EQ CHARLIT:val
            {:
              RESULT = Character.valueOf(val.toString().charAt(0));
              System.out.println("EL ID DE CHARLIT ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val); 
            :}
          |
          CHAR ID:id EQ functionInv:val
          ;
stringCreationAssign ::=
          STRING ID:id 
            {:
              System.out.println("EL ID DE STRING ES: " + id);
            :}
          | 
          STRING ID:id EQ STRINGLIT:val
            {:
              System.out.println("EL ID DE STRING ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              RESULT = val;
            :}
          ;
boolCreationAssign ::=
          BOOL ID:id 
            {:
              System.out.println("EL ID DE BOOL ES: " + id);
            :} 
          | 
          BOOL ID:id EQ boolLit:val
            {:
              System.out.println("EL ID DE BOOL ES: " + id);
              System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
            :} 
          | 
          BOOL ID EQ logicalExpression
          ;
varAsign ::=
          ID EQ mathExpression
          ;
arrayAccess ::=
          ID LSQUARE INTLIT RSQUARE
          |
          ID LSQUARE ID RSQUARE
          ;
arrayValModification ::=
          //ID LSQUARE INTLIT RSQUARE EQ INTLIT
          //|
          //ID LSQUARE INTLIT RSQUARE EQ ID
          //|
          ID LSQUARE INTLIT RSQUARE EQ mathExpression
          |
          //ID LSQUARE ID RSQUARE EQ INTLIT
          //|
          //ID LSQUARE ID RSQUARE EQ ID
          //|
          ID LSQUARE ID RSQUARE EQ mathExpression
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT LPAREN INTLIT RPAREN
          |
          PRINT LPAREN FLOATLIT RPAREN
          |
          PRINT LPAREN CHARLIT RPAREN
          |
          PRINT LPAREN STRINGLIT RPAREN
          |
          PRINT LPAREN ID RPAREN
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          READ
          ;
// ---------- Expressions ----------
expression ::=
          logRelExpression HASH
          |
          varCreationAsign HASH
          |
          varAsign HASH
          |
          printFunction HASH
          | 
          readFunction HASH
          |
          arrayValModification HASH
          |
          if | while | for  
          |
          error HASH
          ;
boolLit ::=
          TRUE {: RESULT = true; :} | FALSE {: RESULT = false; :}
          ;
unaryExpression ::=
          ID PADD | ID PSUBS 
          |
          INTLIT PADD | INTLIT PSUBS 
          |
          FLOATLIT PADD | FLOATLIT PSUBS 
          ;
mathExpression ::=
          intMathExpression:val
            {:
              System.out.println("EL RESULTADO FINAL ES: " + val);
            :}
          |
          floatMathExpression
          ;
intMathExpression ::=
          intMathExpression:op1 ADD intFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 + op2;
            :}
          |
          intMathExpression:op1 SUBS intFactor:op2
            {:
              System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 - op2;
            :}
          |
          intFactor:val
            {:
              RESULT = convertToInteger(val);
            :}
          ;
intFactor ::=
          intFactor:f MULT intTerm:t
            {: 
              RESULT = convertToInteger(f) * convertToInteger(t); 
            :}
          |
          intFactor:f DIV intTerm:t
            {: 
              RESULT = convertToInteger(f) / convertToInteger(t); 
            :}
          |
          intTerm:t
            {: 
              RESULT = convertToInteger(t); 
            :}
          ;
intTerm ::=
          /*LPAREN intMathExpression:e RPAREN
            {: 
              RESULT = e; 
            :}
          |*/ 
          INTLIT:n
            {: 
              RESULT = convertToInteger(n); 
            :}
          ;
floatMathExpression ::=
          floatMathExpression:op1 ADD floatFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 + op2;
            :}
          |
          floatMathExpression:op1 SUBS floatFactor:op2
            {:
              System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 - op2;
            :}
          |
          floatFactor:val
            {:
              RESULT = convertToFloat(val);
            :}
          ;
floatFactor ::=
          floatFactor:f MULT floatTerm:t
            {: 
              RESULT = convertToFloat(f) * convertToFloat(t); 
            :}
          |
          floatFactor:f DIV floatTerm:t
            {: 
              RESULT = convertToFloat(f) / convertToFloat(t); 
            :}
          |
          floatTerm:t
            {: 
              RESULT = convertToFloat(t); 
            :}
          ;
floatTerm ::=
          /*LPAREN floatMathExpression:e RPAREN
            {: 
              RESULT = e; 
            :}
          |*/ 
          FLOATLIT:n
            {: 
              RESULT = convertToFloat(n); 
            :}
          ;
logRelExpression ::=
          logicalExpression | relationalExpression
          ;
relationalExpression ::=
          relationalOperand relationalOperator relationalOperand
          ;
logicalExpression ::=
          logicalOperand logicalOperator logicalExpr //HASH
          ;
logicalExpr ::=
          logicalOperand
          |
          logicalOperand logicalOperator logicalExpr
          ;
// ---------- Operands and operators ----------
mathOperand ::=
          //unaryExpression | ID | functionInv | 
          intMathOperand:val {: RESULT = val; :}
          | 
          floatMathOperand:val {: RESULT = val; :}
          ;
intMathOperand ::=
          INTLIT:val {: RESULT = convertToInteger(val); :} //| arrayAccess  
          ;
floatMathOperand ::=
          FLOATLIT:val {: RESULT = convertToFloat(val); :}
          ;
relationalOperand ::=
          mathOperand | LPAREN mathExpression RPAREN
          ;
logicalOperand ::=
          ID | boolLit | functionInv | LPAREN relationalExpression RPAREN
          ;
mathOperator ::=
          ADD | SUBS | DIV | MULT | EXP | MOD
          ;
relationalOperator ::=
          GTE | GT | LTE | LT
          ;
logicalOperator ::=
          AND | OR | EQEQ | NOT
          ;
// ---------- IF THEN ELSE structure ----------

if ::=  // Add rule to make it work with a boolean literal: true/false
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY
        |
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY ELSE LCURLY codeBlock RCURLY
        ;
// ---------- WHILE structure ----------
while ::=
        WHILE LPAREN logRelExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- FOR structure ----------
for ::=
        FOR LPAREN INT ID EQ zero COMMA logRelExpression COMMA unaryExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- SWITCH structure ----------
/*
switch ::=
        SWITCH LPAREN ID RPAREN LCURLY switchBody RCURLY
        ;
switchBody ::=
        CASE INTLIT COLON codeBlock | DEFAULT
        |
        CASE INTLIT COLON codeBlock switchBody
        ;
*/
zero ::=
        INTLIT
        ;