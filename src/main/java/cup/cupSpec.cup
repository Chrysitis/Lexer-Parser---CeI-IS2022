// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import java.io.FileReader;
import java.io.BufferedReader;
import fileManager.*;

/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s){ this.s=s; }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;

    @Override
    public void syntax_error(Symbol current_token) {
      String errInfo = "SYNTAX ERROR AT LINE " + (current_token.left) + " COLUMN " 
        + (current_token.right) + " VALUE: " + current_token.value + " - ";
      System.out.println(errInfo); 
      reportErrToFile(errInfo);
      this.syntaxErrs += 1;
    }    

    private void reportErrToFile(String info){
      FileManager fileManager = new FileManager("C:/Users/chris/Documents/NetBeansProjects/CeI-PYI/src/main/java/symbolTable/Tokens.txt");
      fileManager.writeToFile(info);
  }
    public void initParser(String file){
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    new Lexer(br));
            Object result = codeParser.parse().value;
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
            System.out.println(this.syntaxErrs);
        } catch (Exception ex) {
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            //ex.printStackTrace();
        }
    }

    public void fun() {
    
      System.out.println("SE EJECUTO EL CODIGO DENTRO DEL PROCESO.");
    }

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    INTARR, CHARARR;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE, DEFAULT;
terminal    RETURN, MAIN, FUNC;
terminal    READ, PRINT;
terminal    COMMENT;

// Boolean.
terminal    TRUE, FALSE;

// Literals.
terminal    INTLIT, FLOATLIT;
terminal    CHARLIT, STRINGLIT;
terminal    ARRAYLIT;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA, COLON;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Identifiers.
terminal    ID;

/* Non terminals */
non terminal    ini;       
//non terminal    Integer  expr;      
non terminal    main, function, functionInv;    
non terminal    codeBlock;
non terminal    varCreationAsign, varAsign;
non terminal    printFunction, readFunction;
non terminal    expression, mathExpression, logRelExpression;
non terminal    unaryExpression;
non terminal    parameters, parametersInv;
non terminal    literal, numLiteral, lettersLiteral, boolLit;
non terminal    logicalExpression, logicalExpr, relationalExpression;
non terminal    mathOperand, relationalOperand, logicalOperand;
non terminal    mathOperator, relationalOperator, logicalOperator;
non terminal    if, while, for, switch, switchBody;
non terminal    zero;
non terminal    arrayAccess, arrayValModification;
non terminal    return;
//non terminal  expr, factor, termino;
// Precedence and associativity declarations

// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          main | function
          |
          main ini
          |
          function ini
          ;

// ---------- main function (no params, MAIN is recognized as main()) ----------
main ::= 
          INT MAIN LCURLY return HASH RCURLY {:System.out.println("ESTE ES EL MAIN");:}
          |
          INT MAIN LCURLY codeBlock return HASH RCURLY
          ;
return ::=
          RETURN ID | RETURN INTLIT | RETURN FLOATLIT | RETURN CHARLIT
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.
  The lexeme is "functionName(", that is why RPAREN is missing. */
function ::=
          INT FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          CHAR FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          FLOAT FUNC RPAREN LCURLY codeBlock return HASH RCURLY
          |
          INT FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          |
          CHAR FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          |
          FLOAT FUNC parameters RPAREN LCURLY codeBlock return HASH RCURLY
          ;
functionInv ::=
          FUNC RPAREN
          |
          FUNC parametersInv RPAREN
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID:param COMMA parameters 
            {: 
              RESULT = param;
              System.out.println("PARAMETRO ES: " + param);
            :}
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT | STRINGLIT | boolLit | ID | functionInv
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          boolLit COMMA parametersInv
          |
          ID COMMA parametersInv
          |
          functionInv COMMA parametersInv
          ;
// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          expression | COMMENT
          |
          expression codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreationAsign ::=   
          INT ID | INT ID EQ mathExpression
          |
          FLOAT ID | FLOAT ID EQ mathExpression
          |
          CHAR ID | CHAR ID:id EQ CHARLIT {: System.out.println("EL ID ES:" + id); :} | CHAR ID EQ functionInv
          |
          BOOL ID | BOOL ID EQ boolLit | BOOL ID EQ logicalExpression
          |
          INTARR INTLIT RSQUARE ID | INTARR INTLIT RSQUARE ID EQ ARRAYLIT
          |
          CHARARR INTLIT RSQUARE ID | CHARARR INTLIT RSQUARE ID EQ ARRAYLIT
          |
          STRING ID | STRING ID EQ STRINGLIT
          ;
varAsign ::=
          ID EQ mathExpression
          ;
arrayAccess ::=
          ID LSQUARE INTLIT RSQUARE
          |
          ID LSQUARE ID RSQUARE
          ;
arrayValModification ::=
          //ID LSQUARE INTLIT RSQUARE EQ INTLIT
          //|
          //ID LSQUARE INTLIT RSQUARE EQ ID
          //|
          ID LSQUARE INTLIT RSQUARE EQ mathExpression
          |
          //ID LSQUARE ID RSQUARE EQ INTLIT
          //|
          //ID LSQUARE ID RSQUARE EQ ID
          //|
          ID LSQUARE ID RSQUARE EQ mathExpression
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT LPAREN INTLIT RPAREN
          |
          PRINT LPAREN FLOATLIT RPAREN
          |
          PRINT LPAREN CHARLIT RPAREN
          |
          PRINT LPAREN STRINGLIT RPAREN
          |
          PRINT LPAREN ID RPAREN
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          READ
          ;
// ---------- Expressions ----------
expression ::=
          mathExpression
          |
          unaryExpression HASH
          |
          logRelExpression HASH
          |
          varCreationAsign HASH
          |
          varAsign HASH
          |
          printFunction HASH
          | 
          readFunction HASH
          |
          functionInv HASH
          |
          arrayAccess HASH
          |
          arrayValModification HASH
          |
          if | while | for  
          |
          error HASH
          ;
literal ::=
          numLiteral | lettersLiteral | boolLit
          ;
numLiteral ::=
          INTLIT | FLOATLIT
          ;
lettersLiteral ::=
          CHARLIT | STRINGLIT
          ;
boolLit ::=
          TRUE | FALSE
          ;
unaryExpression ::=
          ID PADD | ID PSUBS 
          |
          INTLIT PADD | INTLIT PSUBS 
          |
          FLOATLIT PADD | FLOATLIT PSUBS 
          ;
mathExpression ::=
          mathOperand
          |
          mathOperand:o1 mathOperator mathExpression:o2
            {: 
              System.out.println("El primer operador es: " + o1);
              System.out.println("Resultado es: " + Integer.parseInt(o1) + Integer.parseInt(o2));
            :} 
          ;
logRelExpression ::=
          logicalExpression | relationalExpression
          ;
relationalExpression ::=
          relationalOperand relationalOperator relationalOperand
          ;
logicalExpression ::=
          logicalOperand logicalOperator logicalExpr //HASH
          ;
logicalExpr ::=
          logicalOperand
          |
          logicalOperand logicalOperator logicalExpr
          ;
// ---------- Operands and operators ----------
mathOperand ::=
          literal | functionInv | ID | arrayAccess | unaryExpression
          ;
relationalOperand ::=
          mathOperand | LPAREN mathExpression RPAREN
          ;
logicalOperand ::=
          ID | boolLit | functionInv | LPAREN relationalExpression RPAREN
          ;
mathOperator ::=
          ADD | SUBS | DIV | MULT | EXP | MOD
          ;
relationalOperator ::=
          GTE | GT | LTE | LT
          ;
logicalOperator ::=
          AND | OR | EQEQ | NOT
          ;
// ---------- IF THEN ELSE structure ----------

if ::=  // Add rule to make it work with a boolean literal: true/false
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY
        |
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY ELSE LCURLY codeBlock RCURLY
        ;
// ---------- WHILE structure ----------
while ::=
        WHILE LPAREN logRelExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- FOR structure ----------
for ::=
        FOR LPAREN INT ID EQ zero COMMA logRelExpression COMMA unaryExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- SWITCH structure ----------
switch ::=
        SWITCH LPAREN ID RPAREN LCURLY switchBody RCURLY
        ;
switchBody ::=
        CASE INTLIT COLON codeBlock
        |
        CASE INTLIT COLON codeBlock switchBody
        ;
zero ::=
        INTLIT
        ;