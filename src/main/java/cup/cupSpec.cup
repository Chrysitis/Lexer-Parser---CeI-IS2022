// Misc declarations and user code.
package cup;
import java_cup.runtime.*;
import jflex.*;
import fileManager.*;
import java.util.Map;
import symbolTable.*;
import java.util.ArrayList;
import org.apache.commons.lang3.math.NumberUtils;
import codeGenerator.*;
import java.util.Stack;

/* Parser code to change the way the parser reports errors (include
  line and column number of the error). */

parser code {:
    Scanner s;
    public parser(int t, Scanner s, SymbolTableManager manager, Lexer lexer){ 
      this.s=s; 
      this.stManager = manager;
      this.lexer = lexer;
      }
    public boolean syntaxErrors;
    public int syntaxErrs = 0;
    public SymbolTableManager stManager;
    public SymbolTable currentSymbolTable = null;
    public String currentFunction;
    public Lexer lexer;
    public String currentTemp = "t0";
    public int currentTempCount = 0;
    public String currentBranch = "";
    public Stack<String> mathExprTempsStack = new Stack<>();
    public ArrayList<String> ids = new ArrayList<>();
    public ArrayList<String> idsTemps = new ArrayList<>();
    public boolean uExp = false;


    @Override
    public void syntax_error(Symbol current_token) {
      String errInfo = "SYNTAX ERROR AT LINE " + (current_token.left) + " COLUMN " 
        + (current_token.right) + " VALUE: " + current_token.value;
      System.out.println(errInfo); 
      reportErrToFile(errInfo);
      this.syntaxErrs += 1;
    }    

    public void printArrays() {
      int i = 0;
      int arraySize = ids.size();
      while(i < ids.size()) { 
        System.out.println("ID: " + ids.get(i) + " TEMP: " + idsTemps.get(i));
        System.out.println("hmmmmmmmmmmmmmmmmmmm"); 
        i++;
      }
      System.out.println(ids);
      System.out.println(idsTemps);
}

    public void emptyIdsnTempsArray() {
      this.ids.clear();
      this.idsTemps.clear();
    }

    private void addIdsnTemps(String id, String temp) {
      int i = 0;
      int arraySize = this.ids.size();
      if (arraySize == 0) {
        this.ids.add(id);
        this.idsTemps.add(temp);
      } else {
        while(i < arraySize) {
          if(id.equals(this.ids.get(i))) {
            this.ids.remove(i);
            this.idsTemps.remove(i);
            i = arraySize; 
          }
          i++;
        }
        this.ids.add(id);
        this.idsTemps.add(temp);
      }
      System.out.println(this.ids);
      System.out.println(this.idsTemps);
    }
    private void reportErrToFile(String info){
      FileManager fileManager = new FileManager("C:/Users/chris/Documents/NetBeansProjects/CeI-PYI/src/main/java/symbolTable/Tokens.txt");
      fileManager.writeToFile(info);
    }

    private void generateICode(String info){
      FileManager fileManager = new FileManager("C:/Users/chris/Documents/NetBeansProjects/CeI-PYI/src/main/java/codeGenerator/iCode.txt");
      fileManager.writeToFile(info);
    }

    // Converts String to Integer.
    private Integer convertToInteger(Object val){
      //System.out.println("**********************VALUE CONVERTING TO INT: " + val);
      return Integer.parseInt(val.toString());
    }
    // Converts String to Float.
    private Float convertToFloat(Object val){
      //System.out.println("**********************VALUE CONVERTING TO FLOAT: " + val);
      return Float.parseFloat(val.toString());
    }
    public void initParser(Lexer lexer){
        //Object result;
        try {
            //BufferedReader br = new BufferedReader(new FileReader(file));
            parser codeParser = new parser(0,
                    s, lexer.getSymbolTableManager(), lexer);
            Object result = codeParser.parse().value;
            //result = codeParser.parse().value;
            System.out.println("THE PARSER RESULT IS: " + result);
            String res = this.syntaxErrs > 0? "THERE WERE " + syntaxErrs + 
              "ERRORS. THE CODE CANNOT BE GENERATED." : "THE CODE CAN BE GENERATED.";
            System.out.println(res);
        } catch (Exception ex) {
            //System.err.println("AT THIS TIME RESULT IS: " + result);
            System.err.println("AN ERROR HAS BEEN FOUND. PROCEEDING WITH THE REST OF THE FILE.");
            ex.printStackTrace();
        }
    }
    
  public void printSymbolTable() {
    int index = 0;
    int size = stManager.getSymbolTables().size();
    for(int i = 0; i < size; i++) {
      System.out.println();
      String funcName = stManager.getSymbolTables().get(i).getFuncName();
      String funcType = stManager.getSymbolTables().get(i).getFuncType();
      String funcReturn = stManager.getSymbolTables().get(i).getReturnVal();
      ArrayList<String> funcParams = stManager.getSymbolTables().get(i).getFuncParams();
      int funcScope = stManager.getSymbolTables().get(i).getTableScope();
      Map<String,ArrayList<String>> current = stManager.getSymbolTables().get(i).getSymbolTable();
      System.out.println("FUNCTION \t SCOPE \t\t VARIABLES \t ATTRIBUTES \t\t FUNC RETURN TYPE \t\t FUNC RETURN VAL \t\t FUNC PARAMS");
      current.forEach(
        (k, v) -> System.out.println(funcName + "\t\t " + funcScope +" \t\t " + k + " \t\t " + v
          + "\t\t\t " + funcType + "\t\t\t " + funcReturn + "\t\t\t\t " + funcParams 
          + "\n_________________________________________________________________________________________________________________________________________________________")
      );
    } 
  }

  public boolean checkVarExistance(String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        if(st.getSymbolTable().containsKey(id)) {
          return true;
        }
      }
    }
    return false;
  }
  // Updates the symbol table entries for type and value for the given id.
  public void updateIntegerSymbolTable(Object id, Object type, Integer val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? Integer.toString(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateFloatSymbolTable(Object id, Object type, Float val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? Float.toString(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateCharacterSymbolTable(Object id, Object type, Character val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? String.valueOf(val) : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateStringSymbolTable(Object id, Object type, String val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? val : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // Updates the symbol table entries for type and value for the given id.
  public void updateBooleanSymbolTable(Object id, Object type, String val) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    ArrayList<String> attributes = new ArrayList<>();
    attributes.add(type.toString());
    attributes.add(val != null? val : null);
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        st.getSymbolTable().
          computeIfPresent(id.toString(), (key, value) -> value = attributes);
      }
    }
  }

  // To manage variable scope and presence.
  public void updateCurrentFunction(Object name) {
    //System.out.println("CURRENT FUNCTION IS: " + name.toString());
    this.currentFunction = name.toString();
  }

    public String getIdValue(String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String res = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        //System.out.println("CURRENT FUNCTION IS: " + this.currentFunction + "ST FUNCTION IS: " + st.getFuncName());
        if(st.getTableScope() != 0){
          res = st.getSymbolTable().get(id).get(1);
          return res;
        }
      }
    }
    return res;
  }

  public String getIdType(String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String res = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        //System.out.println("CURRENT FUNCTION IS: " + this.currentFunction + "ST FUNCTION IS: " + st.getFuncName());
        if(st.getTableScope() != 0){
          if(st.getSymbolTable().containsKey(id)) {
            res = st.getSymbolTable().get(id).get(0);
          } else {
            res = "-e2";
          }
          return res;
        }
      }
    }
    return res;
  }

  public String getFuncType(String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String res = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      System.out.println("COMPARING: " + id + "ST FUNCTION IS: " + st.getFuncName());
      if(st.getTableScope() == 0){
        if(st.getFuncName().equals(id)) {
          res = st.getSymbolTable().get(id).get(0);
          } else {
            res = "-e4";
          }
        }
      } 
    return res;
    }

  // id means refers to variale id and type refers to either variable or function.
  // dataType refers to the required data type for the id to be valid in any operation.
  // Validates the existance of the given id, the scope and value type.
  
public String validateId(String id, String type , String dataType) {    
    // First, validates the existance and scope.
    String result;
    if(validateScope(id)) {
      result = getIdValue(id);
      //System.out.println("RESULT OF ID VALIDATION IS: " + result);
    } else {
      result = "-e1";
    }
    return result;
}

  public String validateFunc(String func, String funcType) {
    
    // First, validates the existance and scope.
    String result = "";
    String res = "";
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    SymbolTable st;
    int limit = sTables.size() - 1;
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i); 
      if(st.getTableScope() == 1) {
        //System.out.println("COMPARING " + st.getFuncName() + " TO " + func);
        if(st.getFuncName().equals(func)) {
          //System.out.println("COMPARING TYPES " + st.getFuncType() + " TO " + funcType);
          if(st.getFuncType().equals(funcType)) {
            res = st.getReturnVal();
            if(!NumberUtils.isParsable(res)) {
                result = getValueFromFunc(func, res);
                return result;
              } else {
                result = st.getReturnVal();
                }
          } else {
            result = "-e2";
            return result;
          }
        }
        result = "-e4";
      }
    }
    return result;
}

  public String getValueFromFunc(String func, String id) {
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    int limit = sTables.size() - 1;
    SymbolTable st;
    String result = "";
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getTableScope() != 0 && st.getFuncName().equals(func)) {        
        result = st.getSymbolTable().get(id).get(1);
        return result;
      }
    }

    return result;
  } 
  public boolean validateScope(String id) {
    boolean result = false;
    ArrayList<SymbolTable> sTables = this.stManager.getSymbolTables();
    SymbolTable st;
    int limit = sTables.size() - 1;
    for (int i = 0; i <= limit; i++) {
      st = sTables.get(i);
      if(st.getFuncName().equals(this.currentFunction)) {
        if (st.getSymbolTable().containsKey(id)) {
          int currentScope = lexer.scope;
          // Checks for current scope.
          if (st.getTableScope() < currentScope) {
            //System.out.println("LA VARIABLE EXISTE EN SCOPE ARRIBA");
            result = true;
          } // Checks if it exists on higher scopes. 
          else if (st.getTableScope() == currentScope) {
            //System.out.println("LA VARIABLE EXISTE EN SCOPE PRESENTE");
            result = true;
          } else {
            result = false;
          }
        }
      }
    }
    //System.out.println("VER SI VARIABLE EXISTE: " + id + " - " + result);
    return result;
  }

  // Reports semantic err according to the number received.
  // -e1 means no such id or no such id in the current scope.
  // -e2 means type conflict.
  // -e3 means id has null value.
  // -e4 means no such function. 
 public String reportSemanticErr(String lexeme, String errType) {
    String err = "";
    if(errType == null) {
      err = "--------------- UNKNOW ERR FOR " + lexeme + ". ---------------";
    } else if(errType.equals("-e1")) {
      err = "--------------- SEMANTIC ERR: NO SUCH VARIABLE " + lexeme + " CREATED OR IN SCOPE. ---------------";
    } else if(errType.equals("-e2")) {
      err = "--------------- SEMANTIC ERR: OPERAND, FUNCTION OR VARIABLE " + lexeme + " DATA TYPE CONFLICT FOR VARIBLE " + lexer.idExamination + ". ---------------";
    } else if(errType.equals("-e4")) {
      err = "--------------- SEMANTIC ERR: NO SUCH FUNCTION " + lexeme + " EXISTS. ---------------";
      } else if(errType.equals("-e5")) {
      err = "--------------- SEMANTIC ERR: UNDECLARED VARIABLE " + lexeme + ".---------------";
      } 
    reportErrToFile(err);
    return err;
}

:}
/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};


// Symbol list (terminals and non terminals)
// Keyword terminals
terminal    INT, FLOAT;
terminal    BOOL;
terminal    CHAR, STRING, ARRAY;
terminal    INTARR, CHARARR;
terminal    BEGIN, END;
terminal    IF, THEN, ELSE;
terminal    FOR, BREAK, WHILE;
terminal    SWITCH, CASE, DEFAULT;
terminal    RETURN, MAIN;
terminal Object         FUNC;
terminal    READ, PRINT;
terminal    COMMENT;

// Separator
terminal    HASH, EQ, EQEQ;
terminal    LPAREN, RPAREN;
terminal    LCURLY, RCURLY;
terminal    LSQUARE, RSQUARE;
terminal    DOT;
terminal    COMMA, COLON;

// Operators.
terminal    ADD, SUBS, MULT, DIV;
terminal    MOD, EXP;
terminal    PADD, PSUBS;
terminal    GTE, GT, LTE, LT;
terminal    AND, OR, NOT;

// Boolean.
terminal Boolean        TRUE, FALSE;

// Literals.
terminal Object         INTLIT;
terminal Object         FLOATLIT;
terminal Object         CHARLIT;
terminal String         STRINGLIT;
terminal    ARRAYLIT;

// Identifiers.
terminal Object         ID;

/* Non terminals */
non terminal    ini;       
non terminal    main, function;
non terminal Object     functionInv;    
non terminal    codeBlock;
non terminal Object     varAsign;
non terminal    printFunction, readFunction;
non terminal    expression;
non terminal Object     logRelExpression;
non terminal Object     unaryExpression;
non terminal    parameters, parametersInv;
non terminal    literal;
non terminal    numLiteral;
non terminal    lettersLiteral;
non terminal Boolean    logicalExpression, logicalExpr;
non terminal Object     relationalExpression;
non terminal Boolean    logicalOperand;
non terminal Object     relationalOperand;
non terminal    mathOperator, relationalOperator;
non terminal Object     logicalOperator;
non terminal    if, while, for, switch, switchBody;
non terminal    zero;
non terminal    arrayAccess, arrayValModification;
non terminal    return;
non terminal Object     varCreationAsign;
non terminal Object     mathExpression;
non terminal    mathOperand;
non terminal Object     intMathExpression;
non terminal Float      floatMathExpression;
non terminal Character  charCreationAssign;
non terminal Object     intCreationAssign;
non terminal Object      floatCreationAssign;
non terminal String     stringCreationAssign;
non terminal Boolean    boolCreationAssign;
non terminal Integer    intMathOperand;
non terminal Float      floatMathOperand;
non terminal Boolean    boolLit;
non terminal Object     intTerm, intFactor;
non terminal Float      floatTerm, floatFactor;
non terminal Object     intVarAsign;
non terminal Object    intUnaryExpression;
non terminal Float      floatUnaryExpression;


// Precedence and associativity declarations
precedence left ADD, SUBS; 
precedence left MULT, DIV;
// The grammar.
start with ini;
// ---------- Init point ----------
ini ::=
          function ini
          |
          main
          ;

// ---------- main function (no params, MAIN is recognized as main()) ----------
main ::= 
          INT MAIN:name 
            {: 
              updateCurrentFunction(name);
              TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null);
              TDCGenerator.reinitTemporal();
              emptyIdsnTempsArray();
              currentTemp = "t0";
              //System.out.println("CURRENT FUNC IS: " + currentFunction); 
            :} 
          LCURLY codeBlock {: TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          ;
return ::=
          RETURN ID:id 
            {:
              TDCGenerator.codeGenerator("RETURN", id.toString(), null, null, null);
            :}
          | RETURN INTLIT:val 
            {:
              TDCGenerator.codeGenerator("RETURN", val.toString(), null, null, null);
            :}
          | RETURN FLOATLIT | RETURN CHARLIT | RETURN STRING
          ;
// ---------- Other functions ----------
/* These include functions with parameters and no parameters. 
  Also, function definition and function invocations.
  The lexeme is "functionName(", that is why RPAREN is missing. */
function ::=
          INT FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          |
          CHAR FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          |
          FLOAT FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          |
          INT FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} parameters RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          |
          CHAR FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} parameters RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          |
          FLOAT FUNC:name {: updateCurrentFunction(name); TDCGenerator.codeGenerator("FUNCB", name.toString(), null, null, null); TDCGenerator.reinitTemporal(); emptyIdsnTempsArray(); currentTemp = "t0"; :} parameters RPAREN LCURLY codeBlock {:TDCGenerator.codeGenerator("FUNCE", name.toString(), null, null, null); :} RCURLY
          ;
functionInv ::=
          FUNC:name RPAREN 
            {:
              RESULT = name;
              //String temp = TDCGenerator.newTemporal();
              //TDCGenerator.codeGenerator("CALL", null, name.toString(), null, null);
            :}
          |
          FUNC parametersInv RPAREN
          ;
// ---------- Parameters/Parameters inv ----------
// Rules for parameters in functions and parameter invocation.
parameters ::= 
          INT ID:id {: System.out.println("PARAM ES: " + id); :} | CHAR ID | BOOL ID | ARRAY ID | STRING ID
          |
          INT ID:param COMMA parameters 
          |
          CHAR ID COMMA parameters
          |
          BOOL ID COMMA parameters
          |
          ARRAY ID COMMA parameters
          |
          STRING ID COMMA parameters
          ;
parametersInv ::=
          INTLIT | FLOATLIT | CHARLIT {: System.out.println("PARAM ES: "); :} | STRINGLIT | boolLit | ID | functionInv
          |
          INTLIT COMMA parametersInv
          |
          FLOATLIT COMMA parametersInv
          |
          CHARLIT COMMA parametersInv
          |
          STRINGLIT COMMA parametersInv
          |
          boolLit COMMA parametersInv
          |
          ID COMMA parametersInv
          |
          functionInv COMMA parametersInv
          ;
// ---------- Block of code ----------
// Block of code with all kind of expressions.
codeBlock ::=
          expression | COMMENT
          |
          expression codeBlock
          |
          COMMENT codeBlock
          ;
// ---------- variable creation and assignation ----------
varCreationAsign ::=   
          intCreationAssign
          |
          floatCreationAssign
          |
          charCreationAssign
          |
          stringCreationAssign
          |
          boolCreationAssign
          |
          INTARR INTLIT RSQUARE ID | INTARR INTLIT RSQUARE ID EQ ARRAYLIT
          |
          CHARARR INTLIT RSQUARE ID | CHARARR INTLIT RSQUARE ID EQ ARRAYLIT
          ;
intCreationAssign ::=
          INT:dType ID:id 
            {:
              RESULT = null;
              //System.out.println("EL ID DE INT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateIntegerSymbolTable(id, dType, null);
              addIdsnTemps(id.toString(), currentTemp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), currentTemp, null, "dataInt");
              currentTemp = TDCGenerator.newTemporal();
            :} 
          | 
          INT:dType ID:id EQ intMathExpression:val
            {:
            //System.out.println("ENTRO A INT:dType ID:id EQ intMathExpression:val");
              if(val.getClass().toString().equals("class java.lang.Integer")) {
                RESULT = val;
                //System.out.println("EL ID DE INT ES: " + id);
                //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
                updateIntegerSymbolTable(id, dType, convertToInteger(RESULT));
              } else {
              System.out.println("*** SEMANTIC ERR *** ID: " + id + " ES INT ES Y ASIGNO FLOAT.");
              }
              //generateICode("\tdataInt " + id + " = " + val.toString());
              //String temp = TDCGenerator.newTemporal();
              //String tempFunc = TDCGenerator.codeGenerator("CALL", temp, val.toString(), null, null);
              //if(!uExp) {
                String temp = mathExprTempsStack.pop();
                addIdsnTemps(id.toString(), temp);
                TDCGenerator.codeGenerator("ASSIGN", id.toString(), temp, null, "dataInt");
                currentTemp = TDCGenerator.newTemporal();
              //} else {
              //  uExp = false;
              //}

            :}
          | 
          INT:dType ID:id EQ floatMathExpression:val
            {:
              RESULT = null;
              System.out.println("*** SEMANTIC ERR *** ID ES INT Y ASIGNO FLOAT.");
            :}
          ;
floatCreationAssign ::=
          FLOAT:dType ID:id
            {:
              RESULT = null;
              //System.out.println("EL ID DE FLOAT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateFloatSymbolTable(id, dType, null);
              addIdsnTemps(id.toString(), currentTemp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), currentTemp, null, "dataChar");
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          FLOAT:dType ID:id EQ intMathExpression:val
            {:
              RESULT = val;
              //System.out.println("EL ID DE FLOAT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateFloatSymbolTable(id, dType, convertToFloat(RESULT));
              //generateICode("\tdataFloat " + id + " = " + val.toString());
              String temp = mathExprTempsStack.pop();
              addIdsnTemps(id.toString(), temp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), temp, null, "dataInt");
              currentTemp = TDCGenerator.newTemporal();
            :}
          ;
charCreationAssign ::=
          CHAR:dType ID:id
            {:
              RESULT = null;
              //System.out.println("EL ID DE CHARLIT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateCharacterSymbolTable(id, dType, RESULT);
              addIdsnTemps(id.toString(), currentTemp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), currentTemp, null, "dataChar");
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          CHAR:dType ID:id EQ CHARLIT:val
            {:
              RESULT = Character.valueOf(val.toString().charAt(1));
              //System.out.println("EL ID DE CHARLIT ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateCharacterSymbolTable(id, dType, RESULT); 
              //generateICode("\tdataChar " + id + " = " + val.toString());
              addIdsnTemps(id.toString(), currentTemp);
              String tempVal = TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              currentTemp = TDCGenerator.newTemporal();
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), tempVal, null, "dataChar");
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          CHAR:dType ID:id EQ functionInv:val
            {:
              String res = validateFunc(val.toString(), "char");
              if (!res.contains("-e")) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = res.charAt(0);
                updateCharacterSymbolTable(id, dType, RESULT);  
              } else {
                System.out.println(reportSemanticErr(val.toString(), res));
                RESULT = null;
              }
              //generateICode("\tdataChar " + id + " = " + "CALL " + val);
              addIdsnTemps(id.toString(), currentTemp);
              String tempFunc = TDCGenerator.codeGenerator("CALL", currentTemp, val.toString(), null, null);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), currentTemp, null, "dataChar");
              currentTemp = TDCGenerator.newTemporal();
           :}
           |
          CHAR:dType ID:id EQ ID:val
            {:
              //System.out.println("ENTRO A functionInv PARA CHAR = " + val.toString());
              String res = validateId(val.toString(), "char", "id");
              if (!res.contains("-e")) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = res.charAt(0);
                updateCharacterSymbolTable(id, dType, RESULT);  
              } else {
                System.out.println(reportSemanticErr(val.toString(), res));
                RESULT = null;
              }
              //generateICode("\tdataChar " + id + " = " + val);
              addIdsnTemps(id.toString(), currentTemp);
              //String valTemp = TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              //currentTemp = TDCGenerator.newTemporal();
              String idTemp = idsTemps.get(ids.indexOf(val.toString()));
              //System.out.println("ID TEMPS IS: " + idTemp);
              //mathExprTempsStack.push(idTemp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), idTemp, null, "dataChar");
              currentTemp = TDCGenerator.newTemporal();
           :}
          | /* SOLO ASIGNACION POR ESTA LADO. */
          ID:id EQ CHARLIT:val
            {:
              String idType = getIdType(id.toString());
              if(idType.equals("char")) {
              RESULT = Character.valueOf(val.toString().charAt(1));
              updateCharacterSymbolTable(id, "char", RESULT); 
              } else {
                System.out.println(reportSemanticErr(id.toString(),"-e2"));
              }
              //generateICode("\tid " + " = " + val); 
              String valTemp = TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              currentTemp = TDCGenerator.newTemporal();
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), valTemp, null, null);  
              currentTemp = TDCGenerator.newTemporal();    
            :}
/*
          |
          ID:id EQ functionInv:val
            {:
              String idType = getIdType(id.toString());
              String funcType = getIdType(val.toString());
              if(idType.equals(funcType)) {
                String res = validateFunc(val.toString(), "char");
                RESULT = Character.valueOf(res.charAt(1));
                updateCharacterSymbolTable(id, "char", RESULT); 
              } else {
                System.out.println(reportSemanticErr(id.toString(),"-e2"));
              }       
            :}
*/
          ;
stringCreationAssign ::=
          STRING:dType ID:id 
            {:
              RESULT = null;
              //System.out.println("EL ID DE STRING ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              updateStringSymbolTable(id, dType, RESULT); 
              TDCGenerator.codeGenerator("CREATE", id.toString(), null, null, "dataString");
            :}
          | 
          STRING:dType ID:id EQ STRINGLIT:val
            {:
              RESULT = val;
              //System.out.println("EL ID DE STRING ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateStringSymbolTable(id, dType, RESULT); 
              //generateICode("\tdataString " + id + " = " + val);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), val.toString(), null, "dataString");
            :}
          | 
          ID:id EQ STRINGLIT:val
            {:
              String idType = getIdType(id.toString());
              if(idType.equals("string")) {
              RESULT = val;
              updateStringSymbolTable(id, "string", RESULT.toString()); 
              } else {
                System.out.println(reportSemanticErr(id.toString(),"-e2"));
              }
              //generateICode("\tid " + " = " + val);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), val.toString(), null, "dataString");
            :}
          ;
boolCreationAssign ::=
          BOOL:dType ID:id 
            {:
              RESULT = null;
              //System.out.println("EL ID DE BOOL ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + RESULT);
              //updateBooleanSymbolTable(id, dType, null.toString());
              updateBooleanSymbolTable(id, dType, "null"); 
              addIdsnTemps(id.toString(), currentTemp);
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), currentTemp, null, "dataBoolean");
              currentTemp = TDCGenerator.newTemporal();
            :} 
          | 
          BOOL:dType ID:id EQ boolLit:val
            {:
              RESULT = val;
              //System.out.println("EL ID DE BOOL ES: " + id);
              //System.out.println(" --> EL VALOR DE " + id + " ES: " + val);
              updateBooleanSymbolTable(id, dType, RESULT.toString()); 
              //generateICode("\tdataBoolean " + id + " = " + val);
              addIdsnTemps(id.toString(), currentTemp);
              String valTemp = TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              currentTemp = TDCGenerator.newTemporal();
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), valTemp, null, "dataBoolean");
              currentTemp = TDCGenerator.newTemporal();
            :} 
          | 
          BOOL ID EQ logicalExpression
          | 
          ID:id EQ boolLit:val
            {:
              String idType = getIdType(id.toString());
              if(idType.equals("boolean")) {
              RESULT = val;
              updateBooleanSymbolTable(id, "boolean", RESULT.toString()); 
              } else {
                System.out.println(reportSemanticErr(id.toString(),"-e2"));
              }
              //generateICode("\tid " + " = " + val);
              addIdsnTemps(id.toString(), currentTemp);
              String valTemp = TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              currentTemp = TDCGenerator.newTemporal();
              TDCGenerator.codeGenerator("ASSIGN", id.toString(), valTemp, null, null);
              currentTemp = TDCGenerator.newTemporal();
            :} 
          ;
varAsign ::=
          intVarAsign
          ;
intVarAsign ::=
          ID:id EQ mathExpression:val
            {:
              RESULT = val;
              //System.out.println("ENTRO A intVarAsign");
              //System.out.println("EL ID ES: " + id);
              System.out.println(" --> LA NUEVA ASIGNACION DE " + id + " ES: " + RESULT);
              if(lexer.idTypeExamination.equals("int")) {
                updateIntegerSymbolTable(id, "int", convertToInteger(val.toString()));
              }else if(lexer.idTypeExamination.equals("float")) {
                updateFloatSymbolTable(id, "float", convertToFloat(val.toString()));
              }
              String idTemp = idsTemps.get(ids.indexOf(id.toString()));
              TDCGenerator.codeGenerator("ASSIGN", idTemp, val.toString(), null, null);
            :} 
          ;
arrayAccess ::=
          ID LSQUARE INTLIT RSQUARE
          |
          ID LSQUARE ID RSQUARE
          ;
arrayValModification ::=
          //ID LSQUARE INTLIT RSQUARE EQ INTLIT
          //|
          //ID LSQUARE INTLIT RSQUARE EQ ID
          //|
          ID LSQUARE INTLIT RSQUARE EQ mathExpression
          |
          //ID LSQUARE ID RSQUARE EQ INTLIT
          //|
          //ID LSQUARE ID RSQUARE EQ ID
          //|
          ID LSQUARE ID RSQUARE EQ mathExpression
          ;
// ---------- Print function ----------
// Print function taking int, float, char and string literals. Also identifiers.
printFunction ::=
          PRINT INTLIT:val RPAREN
            {:
              TDCGenerator.codeGenerator("PRINT", null, val.toString(), null, null);
            :}
          |
          PRINT FLOATLIT RPAREN
          |
          PRINT CHARLIT RPAREN
          |
          PRINT STRINGLIT:val RPAREN
            {:
              TDCGenerator.codeGenerator("PRINT", null, val.toString(), null, null);
            :}
          |
          PRINT ID:val RPAREN
            {:
              TDCGenerator.codeGenerator("PRINT", null, val.toString(), null, null);
            :}
          ;
// ---------- Read function ----------
// I believe this one is just like a system call to read input.
readFunction ::=
          INT ID:val EQ READ
            {:
              TDCGenerator.codeGenerator("READ", null, val.toString(), null, "dataInt");
            :}
          |
          STRING ID EQ READ
          ;
// ---------- Expressions ----------
expression ::=
          logRelExpression HASH
          |
          varCreationAsign HASH
          |
          varAsign HASH
          |
          printFunction HASH
          | 
          readFunction HASH
          |
          arrayValModification HASH
          |
          if | while | for  
          |
          return HASH
          |
          error HASH
          ;
boolLit ::=
          TRUE {: RESULT = true; :} | FALSE {: RESULT = false; :}
          ;
intUnaryExpression ::=
          ID:id PADD
            {:
              String res;
              Object eval;
              RESULT = 0;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else {
                res = validateId(id.toString(), "float", "id");
              }
              if (NumberUtils.isParsable(res)) {
                if(lexer.idTypeExamination.equals("int")) { 
                  res = validateId(id.toString(), "int", "id");
                  eval = convertToInteger(res) + 1;
                  RESULT = eval;
                  //mathExprTempsStack.push(currentTemp);
                  currentTemp = TDCGenerator.newTemporal();
                } else {
                  res = validateId(id.toString(), "float", "id");
                  eval = convertToFloat(res) + 1.0;       
                  RESULT = eval;          
                }
                String idTemp = idsTemps.get(ids.indexOf(id.toString()));
                String unaryTemp = TDCGenerator.codeGenerator("UEXP", currentTemp, idTemp, "++", "");
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
                uExp = true;              
              } else {
                System.out.println(reportSemanticErr(id.toString(), res));
              }
            :}
          | 
          ID:id PSUBS 
            {:
              String res;
              Object eval;
              RESULT = 0;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else {
                res = validateId(id.toString(), "float", "id");
              }
              if (NumberUtils.isParsable(res)) {
                if(lexer.idTypeExamination.equals("int")) { 
                  res = validateId(id.toString(), "int", "id");
                  eval = convertToInteger(res) - 1;
                  RESULT = eval;
                } else {
                  res = validateId(id.toString(), "float", "id");
                  eval = convertToFloat(res) - 1.0;       
                  RESULT = eval;          
                }   
                String idTemp = idsTemps.get(ids.indexOf(id.toString()));
                TDCGenerator.codeGenerator("UEXP", currentTemp, idTemp, "--", "");
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
                uExp = true;             
              } else {
                System.out.println(reportSemanticErr(id.toString(), res));
              }
            :}
          ;
floatUnaryExpression ::=
          INTLIT PADD | INTLIT PSUBS 
          |
          FLOATLIT PADD | FLOATLIT PSUBS 
          ;
mathExpression ::=
          intMathExpression:val
            {:
              System.out.println("EL RESULTADO FINAL ES: " + val);
            :}
          |
          floatMathExpression
          ;
intMathExpression ::=
          intMathExpression:op1 ADD intFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(op1) + convertToInteger(op2);
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(op1) + convertToFloat(op2);
              }
              String arg2 = mathExprTempsStack.pop();
              TDCGenerator.codeGenerator("ADD", currentTemp, mathExprTempsStack.pop(), arg2, "");
              mathExprTempsStack.push(currentTemp);
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          intMathExpression:op1 SUBS intFactor:op2
            {:
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(op1) - convertToInteger(op2);
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(op1) - convertToFloat(op2);
              }
              String arg2 = mathExprTempsStack.pop();
              TDCGenerator.codeGenerator("SUBS", currentTemp, mathExprTempsStack.pop(), arg2, "");
              mathExprTempsStack.push(currentTemp);
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          intFactor:val
            {:
              //System.out.println("ENTRO A intFactor:val = " + val);
              if(lexer.idTypeExamination.equals("int")) {
                RESULT = convertToInteger(val.toString());
              } else if(lexer.idTypeExamination.equals("float")) {
                RESULT = convertToFloat(val.toString()); 
              }            
            :}
          ;
intFactor ::=
          intFactor:f MULT intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(f.toString()) * convertToInteger(t.toString());
                val = iRes;
                RESULT = val;
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(f.toString()) * convertToFloat(t.toString()); 
                val = fRes;
                RESULT = val;
              }
              String op2 = mathExprTempsStack.pop();
              TDCGenerator.codeGenerator("MULT", currentTemp, mathExprTempsStack.pop(), op2, "");
              mathExprTempsStack.push(currentTemp);
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          intFactor:f DIV intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(f.toString()) / convertToInteger(t.toString());
                val = iRes;
                RESULT = val; 
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(f.toString()) / convertToFloat(t.toString());
                val = fRes;
                RESULT = val;
              }
              String op2 = mathExprTempsStack.pop();
              TDCGenerator.codeGenerator("DIV", currentTemp, mathExprTempsStack.pop(), op2, "");
              mathExprTempsStack.push(currentTemp);
              currentTemp = TDCGenerator.newTemporal();
            :}
          |
          intTerm:t
            {: 
              Float fRes;
              Integer iRes;
              Object val;
              RESULT = 0;
              //System.out.println("ENTRO A intTerm:t = " + t);
              if(lexer.idTypeExamination.equals("int")) {
                iRes = convertToInteger(t.toString()); 
                val = iRes;
                RESULT = val;
              } else if(lexer.idTypeExamination.equals("float")) {
                fRes = convertToFloat(t.toString()); 
                val = fRes;
                RESULT = val;
              }
            :}
          ;
intTerm ::=
          INTLIT:n
            {:
              if(checkVarExistance(lexer.idExamination)) {
                //System.out.println("LA VARIABLE " + lexer.idExamination + " EXISTE");
                if(validateScope(lexer.idExamination)) {
                  //System.out.println("LA VARIABLE " + lexer.idExamination + " TIENE SCOPE VALIDO");
                  //System.out.println("DICE QUE SI EXISTE.");
                  String idType = getIdType(lexer.idExamination);
                  //System.out.println("LA VARIABLE " + lexer.idExamination + " ES DE TIPO " + idType);
                  if(lexer.idTypeExamination.equals("int")) {
                    //System.out.println("LA VARIABLE " + lexer.idExamination + " ES ENTERA");
                    RESULT = n;
                    TDCGenerator.codeGenerator("ASSIGN", currentTemp, n.toString(), null, null);
                    mathExprTempsStack.push(currentTemp);
                    currentTemp = TDCGenerator.newTemporal();                    
                  } else {
                      System.out.println(reportSemanticErr(n.toString(), "-e2"));
                      RESULT = 0;
                    }
                  } else {
                    System.out.println(reportSemanticErr(lexer.idExamination, "-e1"));
                    RESULT = 0;
                  }
              } else {
                System.out.println(reportSemanticErr(lexer.idExamination, "-e5"));
                RESULT = 0;
              }

            :}
          |
          FLOATLIT:n
            {:
              if(checkVarExistance(lexer.idExamination)) {
                if(validateScope(lexer.idExamination)) {
                  String idType = getIdType(lexer.idExamination);
                  if(lexer.idTypeExamination.equals("float")) {
                    RESULT = n;
                    TDCGenerator.codeGenerator("ASSIGN", currentTemp, n.toString(), null, null);
                    mathExprTempsStack.push(currentTemp);
                    currentTemp = TDCGenerator.newTemporal(); 
                  } else {
                    System.out.println(reportSemanticErr(n.toString(), "-e2"));
                    RESULT = 0;
                    }
                } else {
                  System.out.println(reportSemanticErr(lexer.idExamination, "-e1"));
                  RESULT = 0;
                  }
              } else {
                System.out.println(reportSemanticErr(lexer.idExamination, "-e5"));
                RESULT = 0;
                }

            :}
          |
          ID:id
            {:
              //System.out.println("ENTRO A ID = " + id);
              Object val = 0;
              String idType = getIdType(lexer.idExamination);
              String res = "";
              if(lexer.idTypeExamination.equals("int") && idType.equals("int")) { 
                res = validateId(id.toString(), "int", "id");
              } else if(lexer.idTypeExamination.equals("float") && idType.equals("float")) {
                res = validateId(id.toString(), "float", "id");
              } else {
                  res = "-e1";
                }
              if (NumberUtils.isParsable(res)) {
                val = res;
                RESULT = val;
                //TDCGenerator.codeGenerator("ASSIGN", currentTemp, n.toString(), null, null);
                String idTemp = idsTemps.get(ids.indexOf(id.toString()));
                //System.out.println("ID TEMPS IS: " + idTemp);
                mathExprTempsStack.push(idTemp);
              } else {
                  System.out.println(reportSemanticErr(id.toString(), res));
                  RESULT = 0;
              }
            :}
            |
          functionInv:n
            {: 
              Object val = 0;
              String res;
              if(lexer.idTypeExamination.equals("int")) { 
                res = validateFunc(n.toString(), "int");
              } else {
                res = validateFunc(n.toString(), "float");
              }
              if (NumberUtils.isParsable(res)) {
                val = res;
                RESULT = val;
                String tempFunc = TDCGenerator.codeGenerator("CALL", currentTemp, n.toString(), "", "");
                currentTemp = TDCGenerator.newTemporal();
              } else {
                System.out.println(reportSemanticErr(n.toString(), res));
                RESULT = val;
              }
            :}
            |
            intUnaryExpression:val
              {:
                RESULT = val;
              :}
          ;
/*
floatMathExpression ::=
          floatMathExpression:op1 ADD floatFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 + op2;
            :}
          |
          floatMathExpression:op1 SUBS floatFactor:op2
            {:
              //System.out.println("HAY OPERACION: " + op1 + " + " + op2 + " = " + (op1 + op2));
              RESULT = op1 - op2;
            :}
          |
          intFactor:val
            {:
              RESULT = convertToFloat(val);
            :}
          ;

floatFactor ::=
          floatFactor:f MULT floatTerm:t
            {: 
              RESULT = convertToFloat(f) * convertToFloat(t); 
            :}
          |
          floatFactor:f DIV floatTerm:t
            {: 
              RESULT = convertToFloat(f) / convertToFloat(t); 
            :}
          |
          floatTerm:t
            {: 
              RESULT = convertToFloat(t); 
            :}
          ;
floatTerm ::=
          FLOATLIT:n
            {: 
              RESULT = convertToFloat(n); 
            :}
          |
          ID:id
            {:
              //RESULT = 99;
              //System.out.println("ENTRO A ID = " + id);
              String validation = validateId(id.toString(), "float", "id");
              //System.out.println("VALIDATION AT FINAL IS: " + validation);
              if (NumberUtils.isParsable(validation)) {
                RESULT = convertToFloat(validation); 
              } else {
                System.out.println(reportSemanticErr(id.toString(), validation));
                RESULT = 0;
              }
            :}
            |
          functionInv:n
            {: 
              System.out.println("ENTRO A functionInv = " + n.toString());
              String res = validateFunc(n.toString(), "float");
              if (NumberUtils.isParsable(res)) {
                //System.out.println("ENTRO A PARSABLE");
                RESULT = convertToInteger(res);
              } else {
                System.out.println(reportSemanticErr(n.toString(), res));
                RESULT = 0;
              }
            :}
            |
            intUnaryExpression:val
              {:
                if(val.getClass().toString().equals("class java.lang.Float")) {
                  RESULT = val;
                } else {
                  System.out.println(reportSemanticErr("", "-e2"));
                }
                
              :}

          ;*/
logRelExpression ::=
          logicalExpression 
            {:
              String op1 = mathExprTempsStack.pop();
              currentBranch = TDCGenerator.newBranch();
              TDCGenerator.codeGenerator("IF", null, op1, currentBranch, null);
              TDCGenerator.codeGenerator("BRANCH", null, "BEGIN", currentBranch, null);  
           :} 
          | 
          relationalExpression
            {:
              String op1 = mathExprTempsStack.pop();
              currentBranch = TDCGenerator.newBranch();
              TDCGenerator.codeGenerator("IF", null, op1, currentBranch, null);
              TDCGenerator.codeGenerator("BRANCH", null, "BEGIN", currentBranch, null);  
           :}
          ;
relationalExpression ::=
          relationalOperand:v1 relationalOperator:op relationalExpression:v2
            {:
              if(op.toString().equals(">=")) {
                RESULT = convertToInteger(v1) >= convertToInteger(v2);
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("GTE", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals(">")) {
                RESULT = convertToInteger(v1) > convertToInteger(v2);
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("GT", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("<")) {
                RESULT = convertToInteger(v1) < convertToInteger(v2);
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("LT", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("<=")) {
                RESULT = convertToInteger(v1) <= convertToInteger(v2);
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("LTE", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              }
              System.out.println("EL RESULTADO DE RELATIONAL EXPRESSION WITH: " + v1 + " " + op + " " + v2 + " IS " + RESULT);
            :}
          |
          relationalOperand:val
            {:
              RESULT = val;
            :}
          ;
logicalExpression ::=
          logicalOperand:v1 logicalOperator:op logicalExpr:v2
            {:
              if(op.toString().equals("&&")) {
                RESULT = v1 && v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("AND", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("||")) {
                RESULT = v1 || v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("OR", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("==")) {
                RESULT = v1 == v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("EQEQ", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              }
              System.out.println("EL RESULTADO DE LOGICAL EXPRESSION WITH: " + v1 + " " + op + " " + v2 + " IS " + RESULT);
            :}
          |
          logicalOperand:v1 
            {:
              RESULT = v1;
            :}
          ;
logicalExpr ::=
          logicalOperand:v1
            {:
              RESULT = v1;
            :}
          |
          logicalOperand:v1 logicalOperator:op logicalExpr:v2
            {:
              if(op.toString().equals("&&")) {
                RESULT = v1 && v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("AND", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("||")) {
                RESULT = v1 || v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("OR", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              } else if(op.toString().equals("==")) {
                RESULT = v1 == v2;
                String op2 = mathExprTempsStack.pop();
                TDCGenerator.codeGenerator("EQEQ", currentTemp, mathExprTempsStack.pop(), op2, null);
                mathExprTempsStack.push(currentTemp);
                currentTemp = TDCGenerator.newTemporal();
              }
              System.out.println("EL RESULTADO DE LOGICAL EXPR WITH: " + v1 + " " + op + " " + v2 + " IS " + RESULT);
            :}
          ;
// ---------- Operands and operators ----------
mathOperand ::=
          //unaryExpression | ID | functionInv | 
          intMathOperand:val {: RESULT = val; :}
          | 
          floatMathOperand:val {: RESULT = val; :}
          ;
intMathOperand ::=
          INTLIT:val 
            {: 
              RESULT = convertToInteger(val); 
              TDCGenerator.codeGenerator("ASSIGN", currentTemp, val.toString(), null, null);
              mathExprTempsStack.push(currentTemp);
              currentTemp = TDCGenerator.newTemporal();
            :} //| arrayAccess 
          ;
floatMathOperand ::=
          FLOATLIT:val {: RESULT = convertToFloat(val); :}
          ;
relationalOperand ::=
          intMathOperand:val 
            {: 
              RESULT = val; 
            :} 
//| LPAREN mathExpression RPAREN
          ;
logicalOperand ::=
          // ***** Hay que validar que el ID exista, este en scope y no sea null. *****
          ID:id 
            {:
              Boolean res = Boolean.parseBoolean(getIdValue(id.toString()));
              System.out.println("LOGICAL OPERAND IS: " + res );
              RESULT = res;
              String idTemp = idsTemps.get(ids.indexOf(id.toString()));
              mathExprTempsStack.push(idTemp);
            :}
          //| boolLit 
          | LPAREN relationalExpression:val RPAREN {: RESULT = Boolean.parseBoolean(val.toString()); :}
          ;
mathOperator ::=
          ADD | SUBS | DIV | MULT | EXP | MOD
          ;
relationalOperator ::=
          GTE {: RESULT = (Object) ">="; :} 
          | 
          GT {: RESULT = (Object) ">"; :} 
          | 
          LTE {: RESULT = (Object) "<="; :} 
          | 
          LT {: RESULT = (Object) "<"; :}
          ;
logicalOperator ::=
          AND {: RESULT = (Object) "&&"; :} 
          | 
          OR {: RESULT = (Object) "||"; :} 
          | 
          EQEQ {: RESULT = (Object) "=="; :}
          | 
          NOT
          ;
// ---------- IF THEN ELSE structure ----------

if ::=  // Add rule to make it work with a boolean literal: true/false
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY
         {:
          TDCGenerator.codeGenerator("BRANCH", null, "END", currentBranch, null);  
         :} 
        |
        IF LPAREN logRelExpression RPAREN THEN LCURLY codeBlock RCURLY ELSE LCURLY codeBlock RCURLY
        ;
// ---------- WHILE structure ----------
while ::=
        WHILE LPAREN logRelExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- FOR structure ----------
for ::=
        FOR LPAREN INT ID EQ zero COMMA logRelExpression COMMA unaryExpression RPAREN LCURLY codeBlock RCURLY
        ;
// ---------- SWITCH structure ----------
/*
switch ::=
        SWITCH LPAREN ID RPAREN LCURLY switchBody RCURLY
        ;
switchBody ::=
        CASE INTLIT COLON codeBlock | DEFAULT
        |
        CASE INTLIT COLON codeBlock switchBody
        ;
*/
zero ::=
        INTLIT
        ;